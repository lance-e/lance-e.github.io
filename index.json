[{"categories":["杂事"],"content":"我的2023年度总结","date":"2024-01-02","objectID":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","tags":["杂事"],"title":"2023年度总结","uri":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["杂事"],"content":"2023年度总结🥳 ","date":"2024-01-02","objectID":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:0","tags":["杂事"],"title":"2023年度总结","uri":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["杂事"],"content":"前言 看到很多学长都在写年度总结，那我也跟个风吧，记录一下过去一年的收获和感悟吧。马上就是期末周，太多东西要学，后面应该没多少时间，索性就现在写了。 ","date":"2024-01-02","objectID":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:1","tags":["杂事"],"title":"2023年度总结","uri":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["杂事"],"content":"经历 高考 现在回想起来好像教室，食堂，寝室三点一线，也没有什么能回想的起来了。 高考发挥正常，来了重邮🥹，对自己的实力还是有预期，也没什么大不了了。 暑假 18年以来，可以说今年的暑假是最充实的一个暑假了😎。 回想起往年的暑假都是天天打游戏，打得昏天黑地。今年的暑假还是学到了很多东西。 刚考完高考，志愿填报全填的计算机专业，就准备进军互联网~~（不知道找工作时的自己会不会怪自己,互联网寒冬了）~~，开始网上找编程的教程学习，当时不知道要学什么编程语言，看网上推荐就开始学习python了。当时就看好了重邮，志愿一半都是重邮，就阴差阳错加了重邮的贴吧群，到处问学长学姐。 群里有一个学姐主动加了我（人很好，但是是卖卡的），当时聊了很多，在她那里了解到了软工会学C++，于是我就放弃了学习python，转投C++。也在她那里正式了解到了红岩，蓝山，勤奋蜂等工作室，当时就对这些工作室产生了兴趣。 在贴吧群也认识到了一个红岩的学长（红岩安卓的，现在是腾讯✌️😭），和他沟通之后，他直接建议我学go，docker，linux基础，mysql等等，给当时懵懂的我带来不小的震撼🫨。 之后又了解到了一个同专业同级的大佬，此时我还在学C++的指针，他就已经会了python，C++，go，rust，更不用说数据库和docker那些了。本以为暑假学点C++，能开学薄纱同学，看来还是想多了🤡，哈哈哈哈。 Q:暑假收获到了什么呢？ A:一点点C++语法（至少学校的程序化结构设计的进度还没我快，虽然还讲了一些底层原理啥的，但还是觉得上课耽误学习），go的语法，和部分基础linux命令。另外还有一个驾驶证🪪。 新学期 加入了红岩和蓝山作为学员进一步学习，也了解到了两边的牛逼的学长（比如袁神，王鑫学长，紫雨哥，旭哥等等，此处省略一千字），红岩感觉压力有点大，毕竟要刷人，蓝山压力不是很大，而且还有大工位（对于挤在皇家里面生存的我来说太有诱惑力了）。 根据暑假了解到的一些信息，我坚定地选择了毕业工作的道路，毕竟我也不想浪费两三年的时间去读研，最后本硕同薪的结果（要是一直都是现在这个互联网行情，说不定还找不到工作😭）。 刚开学跟现在期末比起来变化确实很大，更多的是我的心态上，不得不说大学确实很容易让人堕落： 刚开学那会确实学的很快，军训期间一直在看计算机网络，虽然没学多少。然后军训结束国庆放假，一个人守舍，把mysql系统刷了一遍，把表锁行锁啥的学了，就没学了，好像还有读写分离（但是现在就基本只用到简单的crud😅，其他的忘的差不多了）。然后跟着蓝山去年开源出来的课件，把redis和docker浅浅地过了一遍（因为浅，所以后面又学了一遍）。 刚开始我对游戏根本不感兴趣，但是逐渐跟着室友一起打游戏，喜欢上了玩cs2。然后就花了很多时间来跟室友打游戏了，慢慢地也没有之前那么卷了，所以说寝室真的不适合学习。 其他的也没啥好说的了… ","date":"2024-01-02","objectID":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:2","tags":["杂事"],"title":"2023年度总结","uri":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["杂事"],"content":"2024上半年的目标 1.把业务的菜名能学的都学了(这个就比较长远了) 2.最近在尝试复刻一个docker🐳，尽量在寒假之前完成吧 3.坚持在工作室的学习，加入一个工作室 4.学习计算机基础四大件(最近在学习数据结构，争取快点学完吧) 5.坚持每天都刷点leetcode(前提是先学完数据结构与算法) 6.学习C++ 7.学习Rust🦀(最近是没时间学咯) 8.找个女朋友🫣 9.work \u0026\u0026 life balance🥹 to be continue…","date":"2024-01-02","objectID":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:3","tags":["杂事"],"title":"2023年度总结","uri":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["数据结构与算法"],"content":"学习笔记","date":"2023-12-24","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(二)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/"},{"categories":["数据结构与算法"],"content":"数据结构与算法入门(二) ","date":"2023-12-24","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/:0:0","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(二)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/"},{"categories":["数据结构与算法"],"content":"第三章（续） 静态链表（游标实现法）： 让数组的元素都是由两个数据域组成，data和cur。也就是 说，数组的每个下标都对应一个data和一个cur。数据域data，用来存 放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的 next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标。 #define MAXSIZE 1000 typedef struct { ElemType data; int cur;//游标Cursor,为0表示无指向 }Component, StaticLinkList[MAXSIZE]; //对于不提供结构struct的程序设计语言，可以使用一对并行数据data和cur来处理 初始化静态链表： //初始化数组状态 Status InitList(StaticLinkList space){ int i ; for (i = 0 ; i \u003cMAXSIZE-1;i++){ space[i].cur = i +1; } space[MAXSIZE -1 ].cur = 0;//最后一个元素的cur存放第一个有数值的元素的下标，相当于单链表中的头结点作用 return OK; } 静态链表的插入操作： 为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过 的及已被删除的分量用游标链成一个备用的链表，每当进行插入时， 便可以从备用链表上取得第一个结点作为待插入的新结点。 int Malloc_SLL(StaticLinkList space ){ //返回第一个备用空闲的下标 int i = space[0].cur; if (space[0].cur){ //因为把第一个空闲的下标返回，所以需要把下一个分量拿来备用 space[0].cur = space[i].cur; } return i; } 具体实现： //在第i个元素前插入新的数据元素e Status ListInsert(StaticLinkList L , int i ,ElemType e){ int j , k , l; //k是最后一个元素的下标 k = MAXSIZE -1; if (i\u003c1 || i \u003e ListLength(L)+1){ return ERROR; } j = Malloc_SLL(L);//返回空闲分量的游标 if (j ){ L[j].data = e; //循环找到第i个元素之前的位置 for ( l = 1; l \u003ci -1 ; l++){ k = L[k].cur;//k = 第i-1个元素的游标 } L[j].cur = L[k].cur;//让插入元素的cur指向第i个元素 L[k].cur = j;//让第i-1个元素的cur指向新元素 return OK; } return ERROR; } 静态链表的删除操作： Status ListDelete(StaticLinkList L, int i ){ int j , k ; if (i \u003c1 || i \u003eListLength(L)){ return ERROR; } k = MAXSIZE -1; for (j = 1;j\u003c=i -1;j++){ k = L[k].cur; } j = L[k].cur; L[k].cur = L[j].cur; Free_SSL(L,j); return OK; } //将下标为k的空闲结点回收到备用链表 Status Free_SSL(StaticLinkList space,int k ){ //把备用链表的第一个元素的cur值赋给要删除的分量的cur space[k].cur =space[0].cur; //要删除的分量下标赋值给备用链表的第一个元素的cur space[0].cur = k; } 获取静态链表的元素个数： //返回静态链表的数据元素的个数 int ListLength(StaticLinkList L){ int j =0 ; int i = L[MAXSIZE -1 ].cur; while(i){ i = L[i].cur; j++; } return j; } 循环链表： 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单 链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。 （不用头指针，而是使用指向终端结点的尾指针） 合并两个循环链表的操作： /* 保存A表的头结点，即① */ p = rearA-\u003enext; /*将本是指向B表的第一个结点（不是头结点） */ rearA-\u003enext = rearB-\u003enext-\u003enext; /* 赋值给reaA-\u003enext，即② */ q = rearB-\u003enext; /* 将原A表的头结点赋值给rearB-\u003enext，即③ */ rearB-\u003enext = p; /* 释放q */ free(q); 双向链表： 双向链表（double linkedlist）：是在单向链表的每个结点中，再设置以一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针 域，一个指向直接后继，另一个指向直接前驱。 代码实现： typedef struct DulNode{ ElemType data; struct DulNode *prior;//直接前驱指针 struct DulNode *next ;//直接后续指针 }DulNode,*DuLinkList; ","date":"2023-12-24","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/:0:1","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(二)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/"},{"categories":["数据结构与算法"],"content":"第四章 栈与队列 4.2.1栈的定义： 栈(stack)是限定仅在表尾进行插入和删除操作的线性表 我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底 (bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出 (LastIn First Out)的线性表，简称LIFO结构。 栈的插入操作：也叫进栈，压栈，入栈（push） 栈的删除操作：也叫出栈，弹栈（pop） 4.3栈的抽象数据类型 ADT 栈(stack) Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。 Operation InitStack(*S): //初始化操作，建立一个空栈S。 DestroyStack(*S): // 若栈存在，则销毁它。 ClearStack(*S): //将栈清空。 StackEmpty(S): // 若栈为空，返回true，否则返回false。 GetTop(S, *e): //若栈存在且非空，用e返回S的栈顶元素。 Push(*S, e): //若栈S存在，插入新元素e到栈S中并成为栈顶元素。 Pop(*S, *e): // 删除栈S中栈顶元素，并用e返回其值。 StackLength(S): // 返回栈S的元素个数。 endADT 4.4栈的顺序存储结构及其实现 结构定义： //SElemType 视实际情况而定，这里假设为int typedef int SElemType ; const int MAXSIZE = 5; typedef struct { SElemType data[MAXSIZE]; int top;//表示栈顶指针 }SqStack; 进栈操作(push): //push Status Push (SqStack *S , SElemType e ) { //栈满 if (S-\u003etop ==MAXSIZE-1){ return ERROR; } //栈顶指针加一 S-\u003etop ++; //将新插入的元素赋值到栈顶 S-\u003edata[S-\u003etop]=e; return OK; } 出栈操作(pop): //pop //若栈不空，则删除S的栈顶元素，用e返回其值， 并返回OK;否则返回ERROR Status Pop(SqStack *S,SElemType e) { //空栈 if (S -\u003etop ==-1){ return ERROR; } e=S-\u003edata[S-\u003etop]; S-\u003etop--; return OK; } 4.5两栈共享空间 结构： //两栈共享空间 typedef struct { SElemType data[MAXSIZE]; int top1; //栈一栈顶指针 int top2; //栈二栈顶指针 }SqDoubleStack; 插入操作： Status Push(SqDoubleStack *S,SElemType e,int StackNumber) { //栈满了 if (S-\u003etop1 +1 == S-\u003etop2) { return ERROR; } if (StackNumber == 1) S-\u003edata[++S-\u003etop1]=e; else if (StackNumber ==2) S-\u003edata[--S-\u003etop2]=e; return OK; } 删除操作： //如果栈不为空，就用e返回删除的值，并且返回ok，失败则返回error Status Pop(SqDoubleStack *S,SElemType *e,int StackNumber ) { if (StackNumber == 1){ if (S-\u003etop1 ==-1) { //说明栈一为空 return ERROR; } *e = S-\u003edata[S-\u003etop1--]; } else if (StackNumber ==2){ if (S-\u003etop2 ==-1) { //说明栈二为空 return ERROR; } *e = S-\u003edata[S-\u003etop2++]; } return OK; } 4.6 栈的链式存储结构及实现 栈的链式存储结构，简称链栈 //链栈的结构定义 //链栈结点 typedef struct StackNode { SElemType data; struct StackNode *next; }StackNode,*LinkStackPtr; //整个链栈 typedef struct LinkStack { LinkStackPtr top;//栈顶指针 int count ; //栈元素个数 }LinkStack; 进栈操作push： //进栈操作 //插入e为新元素到链栈的栈顶 Status Push(LinkStack *S,SElemType e) { LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode)); s-\u003edata = e; //接着将当前栈顶元素赋值给新结点的直接后续， s-\u003enext = S-\u003etop; //将新结点赋值给栈顶指针top S-\u003etop = s; S-\u003ecount ++; return OK; } 出栈操作Pop： //出栈操作 //若栈不为空，就删除栈顶元素并用e来返回删除的元素， //假设变量p用来存储要删除的栈顶元素，将栈顶指针后移一位，再释放掉p Status Pop(LinkStack *S,SElemType *e) { LinkStackPtr p ; //判断栈是否为空 if (StackEmpty(S)){ return ERROR; } *e= S-\u003etop-\u003edata; //将栈顶结点指针赋值给p p = S-\u003etop; //使栈顶指针下移到后一位 S-\u003etop = S-\u003etop-\u003enext; //释放结点p free(p); S-\u003ecount--; return OK; } 4.7栈的应用： 1.递归 递归函数：直接调用自己或通过一系列的调用语句间接地调用自己的函数。 递归过程退回的顺序是它前行顺序的逆序。在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。 因此要实现这样的需求，编译器就是使用栈来实现递归 2.四则运算表达式 1.后缀（逆波兰）表达式：所有的符号都要在运算数字的后面出现 2.后缀表达式运算结果：规则:从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行算，运算结果进栈，一直到最终获得结果 3.中缀表达式：标准的四则运算表达式 4.中缀表达式转换为后缀表达式的规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分;若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。 4.8队列的定义： 队列是只允许在一端进行插入操作，一端进行删除操作的线性表 (First in First out )简称FIFO，允许插入的一头叫做队尾，允许删除的一头叫做队头 4.9队列的抽象数据类型 ADT 队列(Queue) Data //同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。 Operation InitQueue(*Q);//初始化操作，建立一个空队列Q。 DestroyQueue(*Q);//若队列Q存在，则销毁它。 ClearQueue(*Q);//将队列Q清空。 QueueEmpty(Q);// 若队列Q为空，返回true，否则返回false。 GetHead(Q, *e);//若队列Q存在且非空，用e返回队列Q的队头元素。 EnQueue(*Q, e);// 若队列Q存在，插入新元素e到队列Q中并成为队尾元素 DeQueue(*Q, *e);//删除队列Q中队头元素，并用e返回其值 QueueLength(Q);//返回队列Q的元素个数 endADT 4.10循环队列 循序存储结构的不足: 入队列操作，就是在队尾添加一个元素，时间复杂度为O(1) 出队列操作，就是从线性表下标为0的位置出列，全部元素都要移动，时间复杂度为O(n) 当只有一个元素时，队尾和对头重叠，使得操作麻烦，所以引入两个指针，一个是front指向队头元素，一个是rear指向队尾元素 的下一个位置，这样当front和rear相等时，不是只剩一个元素，而是这是一个空队列 如果一个队列即在出列也在入列，使rear超出了线性表的最大元素个数，但是队列队头还有空闲，这样的现象称为“假溢出” 循环队列定义：队头队尾相连的顺序存储结构 循环队列满的条件：(rear+1)%QueueSize==front 循环队列空的条件：rear = front 循环队列队列长度：(rear-front+QueueSize)%QueueSize 循环队列的结构定义: //QElemType的类型视实际情况而定，这里假设为int typedef int QElemType ; typedef struct { QElemType data[MAXSIZE]; int front; int rear;//尾追针，指向队列的队尾元素的下一个位置 }SqQueue; 循环列表初始化操作： Status InitSqQueue(SqQueue *Q){ Q-\u003efront=0; Q-\u003erear=0; return OK; } 获取循环列表的长度： int SqQueueLenth(SqQueue Q","date":"2023-12-24","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/:0:2","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(二)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/"},{"categories":["数据结构与算法"],"content":"第五章 串 5.1串的定义： 串(string)：是指由一个或多个字符组成的有限序列 零个字符的串就是空串 子串就是该串中连续的元素组成的子序列，包含子串的串就是主串 子串的第一个字符在主串的序号就是子串在主串的位置 5.2串的抽象数据类型 ADT 串(string) Data 串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。 Operation StrAssign(T, *chars): StrCopy(T, S): ClearString(S): StringEmpty(S): StrLength(S): StrCompare(S, T): Concat(T, S1, S2): SubString(Sub, S, pos, len) Index(S,T,pos): Replace(S,T,V): StrInsert(S,pos,T): StrDelete(S,pos,len): endADT 5.3串的存储结构 1.串的顺序存储结构：由一组内存地址连续的存储单元进行存储串中的字符序列，一般是根据预定义的长度，为串分配一个定长存储区，一般为定长数组 2.串的链式存储结构：一个结点放一个字符或者多个字符 5.4朴素的模式匹配算法 算法实现： //index //假设S[0],和T[0]存储各字符串的长度 //返回T在S的第pos个字符之后的位置 int Index(string S,string T,int pos){ //i用于S中当前位置下标，若pos不为1，则从pos位置开始 int i = pos; //j用于T中当前位置下标 int j = 1; while(i \u003cS[0] \u0026\u0026j \u003cT[0]) { //两字母相同则继续 if (S[i] == T[j]){ i ++; j++; }else { //不同就指针回退重新开始匹配 /* i退回到上次匹配首位的下一位 */ i = i - j + 2; /* j退回到子串T的首位 */ j = 1; } } if (j == T[0]){ return i -T[0]; }else { return 0; } } 5.5 KMP模式匹配算法 一脸懵逼😳，单独写个博客补充吧😭 ","date":"2023-12-24","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/:0:3","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(二)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/"},{"categories":["云原生"],"content":"docker基础命令，docker的核心技术，dockerfile编写","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["云原生"],"content":"docker 基础知识 ","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:0","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["云原生"],"content":"什么是docker？ Docker!=轻量级虚拟机 Docker使用的是容器化技术，docker利用的是宿主机的操作系统内核 Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问Docker守护进程。 Docker守护进程从客户端接受命令，并按照命令，管理运行在主机上的容器。 一个docker 容器，是一个运行时环境，可以简单理解为进程运行的集装箱。 ","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:1","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["云原生"],"content":"docker 命令简介 熟能生巧，这里仅做总结大部分命令作用，其实见名知意 //常见命令 //容器操作 //容器操作命令都可以加container,例：docker container run XXX docker attach //将本地标准输入、输出和错误流附加到正在运行的容器，通俗的就是可以进入容器 docker run //创建并运行一个容器,选项-d：可以让容器在后台运行 docker exec //进入一个容器,选项-it：保持标准输入打开，并分配一个伪终端 docker stats //展示运行中的容器的状态 docker start //启动一个或多个停止的容器 docker stop //停止一个或多个运行的容器 docker kill //杀死一个或多个运行的容器 docker ps //展示正在运行的容器 docker rm //删除容器 docker rmi //删除镜像 docker rename //重命名容器 docker restart //重启一个或多个容器 docker logs //记录一个容器的日志 docker top //展示运行中容器的进程信息 docker export //导出容器，通常与import联用 docker import //导入容器，通常与export联用 docker pause //暂停一个或多个容器的所有进程 docker unpause //解除一个或多个容器的所有暂停的进程 docker port //展示容器的端口映射关系 docker update //更新容器的配置文件 docker wait //阻塞直到一个或多个容器停止，打印它们的退出代码 docker commit //通过一个容器生成一个镜像 docker cp //从容器和本地主机之间复制文件或文件夹 docker diff //展示容器内文件系统的变更 //镜像操作 docker build //通过dockerfile生成一个镜像 docker images //展示所有镜像 docker pull //从dockerHub中拉取镜像 docker push //将镜像推送到dockerHub docker search //搜索镜像 docker save //存入：将一个或多个镜像打包为tar格式 docker load //加载：加载镜像保存文件，使生成镜像 docker tag //创建指定镜像的标签 (携带image子命令) docker image build //通过dockerfile生成一个镜像 docker image ls //展示所有镜像 docker image pull //拉取镜像 docker image push //推送镜像 docker image history//展示一个镜像的历史 docker image import //从tarball导入内容以创建文件系统映像 docker image inspect//展示一个或多个镜像的的详细信息 docker image load //加载：加载镜像保存文件，使生成镜像 docker image save //存入：将一个或多个镜像打包为tar格式 docker image prune //删除不用的镜像 docker image rm //删除一个或多个镜像 docker image tag //创建指定镜像的标签 //... ok啊～感觉就这些命令常用，没列出来的，还有一些详细参数就查官网吧，官网更详细。 ","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:2","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["云原生"],"content":"docker 的核心技术 先看看AI怎么说？ Linux容器（Linux Containers，LXC）：Docker利用Linux内核提供的容器化技术，实现了隔离进程、文件系统、网络和资源的轻量级虚拟化。Linux容器是Docker实现容器化的基础。 命名空间（Namespaces）：Docker使用命名空间来隔离进程的运行环境，包括PID（进程ID）、网络、IPC（进程间通信）、挂载点和UTS（主机名和域名）等。每个容器都有自己独立的命名空间，使得容器内的进程感知不到宿主机或其他容器的存在。 控制组（Control Groups，cgroups）：Docker利用控制组来限制和分配容器可使用的资源，如CPU、内存、磁盘和网络带宽等。控制组可以对容器进行资源配额和优先级管理，确保容器之间互不干扰。 联合文件系统（UnionFS）：Docker使用联合文件系统将容器的文件系统与宿主机的文件系统进行层叠并共享，以实现镜像的高效存储和容器的快速启动。常用的联合文件系统有AUFS、OverlayFS和DeviceMapper等。 Docker镜像（Docker Image）：Docker镜像是容器运行时的可执行文件，包含了运行一个容器所需的文件系统、依赖库和配置等。镜像可以通过Dockerfile定义和构建，也可以从Docker Hub等镜像仓库中获取。 Docker容器（Docker Container）：Docker容器是基于镜像创建的运行实例，可以独立运行在宿主机上，并与其他容器隔离。容器可以方便地启动、停止、暂停和销毁，提供了一种轻量级、可移植的应用部署方式。 这些核心技术共同构成了Docker的基础架构，使得Docker能够实现高效、可移植、可扩展的容器化应用部署和管理。 (总结到位，有些词汇我也不懂😭) 那么可以看出docker的三大底座：Namespaces,control Groups(cgroups),UnionFS 一.Namespaces(命名空间) Namespase 是linux内核提供的隔离进程资源的方案，虚拟资源的隔离 主要分为了7类 1.PID命名空间：隔离了进程id 2.Mount命名空间：隔离文件系统挂载点 3.Network命名空间：隔离网络设备，ip地址，路由表，防火墙等 4.UTS命名空间：隔离主机和域名 5.IPC命名空间：隔离 System V IPC 和 POSIX 消息队列(这个是啥？没学有点懵)，(IPC是linux进程间数据交互和同步的方式) 6.User命名空间：隔离用户和用户组 7.Cgroup命名空间：隔离进程组间的资源 PID隔离(没看懂，以后补充) 网络隔离： docker 提供的四种网络模式：host,container,none,bridge 默认为网桥模式 在该模式下，除了会分配隔离的网络命名空间，docker还会给容器分配ip地址 docker服务器在主机启动后，会创建一个新的docker0虚拟网桥，之后所有的服务默认情况下都会连接到该虚拟网卡 默认情况下，每个容器在创建的时候都会创建一对虚拟网卡，这一对构成一个数据通道，其中一个网卡会放在容器中，加入到docker0网桥中. docker0会为每个容器分配一个不同的ip地址，并将docker0点ip地址设置为默认网关 网桥 docker0 通过 iptables 中的配置与宿主机器上的网卡相连，所有符合条件的请求都会通过 iptables 转发到 docker0 并由网桥分发给对应的机器。 libnetwork:有待补充 容器网络模型：有待补充 二.CGroups(控制组) CGroups用户隔离宿主机的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。 每一个CGroup都是一组拥有相同属性的进程，CCroup是有层级关系的，子类可以继承父类的隔离标准 (也是挺复杂的，以后补充) 三.UnionFS(联合文件系统) 什么是镜像？ image是docker部署的基本单位，包含程序文件，以及运行所需的资源文件，对外表现为文件的形式(mount点形式) 什么是UnionFS？ UnionFS是linux点文件系统技术，用于将多个文件系统挂载到同一个挂载点 AUFS：Advanced UnionFS，UnionFS先进版,提供更优秀的性能和效率 四.总结： docker = LXC + AUFS(docker = linux container + advance UnionFS) LXC:用来进行资源管理 AUFS:用来进行镜像管理 cgroup，LXC，docker三者的关系： cgroup —–\u003eLXC——\u003edocker 进行层层封装 ","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:3","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["云原生"],"content":"DockerFile的编写 DockerFile 是文本文件， 其中的每条指令都会建立一层，每条指令就对应这一层该如何构建 FROM指定基础镜像 FROM是必备指令，也是第一条指令 可以选择现有的镜像，也可以使用scratch镜像，代表空镜像，这就意味着你不选择任何镜像作为你的基础镜像，那么接下来所写的指令将作为镜像的第一层存在 例如go开发的应用，编译之后直接生成的就是可执行的2进制文件，不需要依赖操作系统，所依赖的库都包含在了可执行文件中，所以很适合使用FROM scratch，让镜像体积变得小巧 RUN执行命令行命令 RUN指令是用来执行命令行命令的 shell格式： RUN \u003c命令\u003e exec格式： RUN [\"可执行文件\",\"参数A\",\"参数B\",...] 因为每条指令对应一层，所以尽量把多条shell命令写在同一条RUN指令中，使用\u0026\u0026连接，可以防止产生臃肿，多层的镜像 Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。 在每一层的构建结尾，记得删除无关文件，也可以避免臃肿的镜像产生 构建镜像 docker build [OPTIONS] PATH | URL | - 例如：docker build -t nginx:v3 . 镜像构建上下文(context) 通过上面的例子可以看到最后有一个 . ，. 表示当前目录，注意不要误认为是DockerFile目录，这是在指定上下文路径。 什么是上下文呢？ docker 在运行时分为docker引擎(服务端守护进程)和客户端工具,docker引擎提供了一组REAT API(docker remote API)，客户端工具通过api远程调用服务端的服务，让我们以为各种docker服务是在本机进行的，实际上是在远程的服务端进行的，这就让我们操控远程服务端引擎更加便捷。 但是，我们构建DockerFile时可不止使用RUN指令，还需要一些本地文件，但是在这样c/s架构下，该如何将本地文件提供给远程服务器？ 所以就引入了上下文这一概念，通过构建上下文，当执行docker build 命令时，就会根据构建的上下文，将所需的本地文件打包，上传到docker引擎，docker引擎展开上下文包就可以获得所有构建所需的文件 COPY ./package.json /app/ 这里的意思就是把**上下文(context)**目录下的package.json文件复制,而不是DockerFile或其他目录下 一般将DockerFile放在空目录下或项目目录下，如何该目录下没有所需文件，需要把文件复制一份，如果有不想上传给docker引擎的文件，可以通过.dockerignore指定不想上传的文件，把该文件从上下文中剔除(类似于.gitignore) DockerFile的命名不一定一定是DockerFile，也不一定是在上下文目录下 其他的 docker build 用法： 1.使用git repo构建 docker build [OPTIONS] PATH | URL | - 我们可以看到docker build 不止可以从上下文目录中构建，还可以从URL中构建，也就是说还可以从git仓库中构建，那么我们将代码上传到 GitHub上，就可以使用docker快速部署 2. 使用tar压缩包 如果URL中是一个tar压缩包，docker会去下载压缩包，并解压后构建镜像 3.从标准输入读取DockerFile进行构建(以后补充) 4.从标准输入读取上下文压缩包进行构建(以后补充) ","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:4","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["云原生"],"content":"DockerFile指令详解 除了以上提到的FROM，RUN基础指令外，还有很多需要的指令： COPY 复制文件 格式： COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] \u003c源路径\u003e... \u003c目标路径\u003e COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] [\"\u003c源路径1\u003e\",... \"\u003c目标路径\u003e\"] 源路径可以是多个，支持通配符，目标路径可以是工作目录的相对路径，也可以是绝对路径，使用相对路径需要使用WORKDIR指令指定工作目录。–chown=: 选项来改变文件的所属用户及所属组。 ADD 也是复制文件，但是比COPY高级 格式：与COPY一样 当复制一个压缩包时，使用ADD可以进行自动解压的功能(如果本来就想把压缩包复制到目标目录，而不解压缩，那就不要用ADD指令) CMD 容器启动命令 格式： shell格式 CMD \u003c命令\u003e exec格式 CMD [\"可执行文件\",\"参数A\",\"参数B\"...] 参数列表格式 CMD [\"参数A\",\"参数B\"...] (指定了ENTRYPOINT后，CMD就用来指定参数) 在运行时也可以指定新的命令来替换镜像设置的默认命令 使用shell格式的命令，实际的命令会被包装为 sh -c 的参数的形式进行执行。 一般格式推荐使用exec格式，指令会被解析为json数组，所以一定要使用双引号 容器前台运行和后台运行的问题： 因为容器内没有后台服务的概念，容器是为了主进程存在的，主进程退出，那么容器也会退出，那么执行shell格式命令时，主进程实际上是sh ，当该条命令结束后，sh也就结束了，主进程退出，那么容器就退出了，所以我们应该使用exec格式命令直接执行可执行文件，并在前台运行 ENTRYPOINT 入口点 ENTRYPOINT格式与RUN格式一样，分为shell和exec格式 ENTRYPOINT也是用来指定容器启动程序和启动参数，可以在运行时替代，需要通过 docker run 的参数 –entrypoint 来指定 当指定了ENTRYPOINT后，CMD指令就是用来指定参数，实际执行时变成了： ENTRYPOINT \u003cCMD\u003e 应用场景一：让镜像想命令一样使用 应用场景二：应用运行前的准备工作 ENV 设置环境变量 就是用来设置环境变量的 格式： ENV \u003ckey\u003e \u003cvalue\u003e ENV \u003ckey1\u003e=\u003cvalue1\u003e \u003ckey2\u003e=\u003cvalue2\u003e... ARG 构建参数 也是用来设置环境变量的，但是与ENV有区别：ARG构建的环境变量在容器运行时是不存在的 格式： ARG \u003c参数名\u003e[=\u003c默认值\u003e] Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 –build-arg \u003c参数名\u003e=\u003c值\u003e 来覆盖。 ARG指令是有生效范围的，如果在FROM前使用，那么定义的参数只能在FROM指令中使用，如果要在FROM后也使用，那么就要在FROM后也要再使用ARG指令，分别指定变量 VOLUME 定义匿名卷 VOLUME指令可以指定某些目录为匿名卷，将动态数据存储在匿名卷中，可以避免用户忘记指定数据卷，使容器正常运行，而不会将动态数据过多的存储在容器存储层 格式： VOLUME [\"路径1\",\"路径2\"] VOLUME \u003c路径\u003e EXPOSE 暴露端口 格式： EXPOSE \u003c端口一\u003e [\u003c端口二\u003e...] EXPOSE指令用于声明端口，也只是用于声明容器打算使用什么端口而已，镜像启动时也不会因为这个声明就启动该端口服务，只是用于方便镜像使用者对容器进行端口映射，另外还可以在运行时随机端口映射时，就是使用docker run -P时，可以随机端口映射到EXPOSE指定的端口 WORKDIR 指定工作目录 WORKDIR用于指定工作目录(或者成为当前目录),就是pwd的命令展示的工作目录 格式： WORKDIR \u003c工作目录\u003e 如果WORKDIR使用的是相对路径，那么所切换的路径与之前WORKDIR有关 USER 指定用户 使用USER指令时，确保用户存在 格式： USER \u003c用户名\u003e[:\u003c用户组\u003e] HEALTHYCHECK 健康检查 格式： HEALTHCHECK [选项] CMD \u003c命令\u003e：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 ONBUILD 当前镜像作为基础镜像执行 ONBUILD指令所指定的指令在当前镜像构建时不会执行，之后当当前镜像作为基础镜像时，才会执行 格式： ONBUILD \u003c其他命令\u003e LABEL 添加元数据 LABEL以减值对的形式给镜像添加元数据 LABEL \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e ... SHELL 指令 用于指定RUN CMD ENTRYPOINT指令的shell,Linux 中默认为 [\"/bin/sh\", “-c”] 格式： SHELL [\"executable\", \"parameters\"] 参考资料： 蓝山第10节课课件 docker技术入门与实战 docker入门到实践 ","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:5","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["leetcode"],"content":"leetcode第86 ，23题题解，23题非最优解","date":"2023-12-20","objectID":"/leetcode8623%E9%A2%98%E8%A7%A3/","tags":["题解"],"title":"Leetcode 86,23题 题解","uri":"/leetcode8623%E9%A2%98%E8%A7%A3/"},{"categories":["leetcode"],"content":"leetcode 86，23 ","date":"2023-12-20","objectID":"/leetcode8623%E9%A2%98%E8%A7%A3/:0:0","tags":["题解"],"title":"Leetcode 86,23题 题解","uri":"/leetcode8623%E9%A2%98%E8%A7%A3/"},{"categories":["leetcode"],"content":"leetcode 第86题：分隔链表 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func partition(head *ListNode, x int) *ListNode { headNode1 := \u0026ListNode{Val:-1,Next:nil} headNode2 := \u0026ListNode{Val:-1,Next:nil} p1 := headNode1 // 小 p2 := headNode2 // 大 p := head for p != nil { if p.Val \u003c x { p1.Next = p p1 = p1.Next }else { p2.Next = p p2 = p2.Next } temp := p.Next p.Next = nil //把该结点断开 p = temp } p1.Next = headNode2.Next return headNode1.Next } ","date":"2023-12-20","objectID":"/leetcode8623%E9%A2%98%E8%A7%A3/:0:1","tags":["题解"],"title":"Leetcode 86,23题 题解","uri":"/leetcode8623%E9%A2%98%E8%A7%A3/"},{"categories":["leetcode"],"content":"leetcode 第23题：合并k个升序链表 最初的做法(最蠢的做法)： 先将所有的链表合并到一个链表中，再对该链表进行冒泡排序. 当然肯定有更优解法，但是！我就只有这点知识😭，所以只能想到这里，看到很多题解是使用优先级队列，所以等我补充完这里的知识就再重刷一遍 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { if lists == nil{ return nil } first := \u0026ListNode{Val: -10000, Next: nil} p := first for _, link := range lists { p.Next = link for p.Next != nil { p = p.Next } } if first.Next == nil{ return first.Next } Sorted := false for !Sorted { current := first Sorted = true for current.Next != nil { if current.Val \u003e current.Next.Val { current.Val, current.Next.Val = current.Next.Val, current.Val Sorted = false } current = current.Next } if Sorted { return first.Next } } return nil } ","date":"2023-12-20","objectID":"/leetcode8623%E9%A2%98%E8%A7%A3/:0:2","tags":["题解"],"title":"Leetcode 86,23题 题解","uri":"/leetcode8623%E9%A2%98%E8%A7%A3/"},{"categories":["leetcode"],"content":"leetcode第一，二十一题题解","date":"2023-12-19","objectID":"/leetcode%E9%A2%98%E8%A7%A3/","tags":["题解"],"title":"Leetcode 1，21题 题解","uri":"/leetcode%E9%A2%98%E8%A7%A3/"},{"categories":["leetcode"],"content":"leetcode 1，21 ","date":"2023-12-19","objectID":"/leetcode%E9%A2%98%E8%A7%A3/:0:0","tags":["题解"],"title":"Leetcode 1，21题 题解","uri":"/leetcode%E9%A2%98%E8%A7%A3/"},{"categories":["leetcode"],"content":"leetcode 第一题：求两数之和 解法一： 暴力枚举： func twoSum(nums []int, target int) []int { for i:=0;i\u003clen(nums)-1;i++{ for n:=i+1;n\u003clen(nums);n++{ if nums[i]+nums[n]==target{ return []int{i,n} } } } return nil } 解法二： 哈希表： func twoSum(nums []int, target int) []int { hashTable := make(map[int]int) for i , v := range nums{ if j,ok :=hashTable[target-v];ok{ return []int{i,j} } hashTable[v]=i; } return nil; } 哈希表使用O(1)的时间查询到了O(n)的信息 暴力枚举使用O(1)的时间只查询到了O(1)的信息 所以哈希表的时间复杂度是O(n),暴力枚举的时间复杂度是O(n^2) ","date":"2023-12-19","objectID":"/leetcode%E9%A2%98%E8%A7%A3/:0:1","tags":["题解"],"title":"Leetcode 1，21题 题解","uri":"/leetcode%E9%A2%98%E8%A7%A3/"},{"categories":["leetcode"],"content":"leetcode 第二十一题：合并两个有序链表 /** \\* Definition for singly-linked list. \\* type ListNode struct { \\* Val int \\* Next *ListNode \\* } */ func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { HeadNode := \u0026ListNode{ Val :-1, Next :nil, } p := HeadNode for list1 != nil \u0026\u0026 list2 != nil{ if list1.Val \u003c list2.Val{ p.Next = list1 list1 = list1.Next }else { p.Next = list2 list2 = list2.Next } p = p.Next } if list1 != nil{ p.Next = list1 } if list2 != nil{ p.Next = list2 } return HeadNode.Next } 先声明了一个虚拟头结点，方便后续操作，也可以不用额外处理指针为空的情况 然后不断比较两个链表，将小的插入到新的链表，并不断让新链表向前移动 Tip(取自labuladong的算法小抄)： 什么时候需要虚拟头结点？ 当创建新的链表时，可以使用虚拟头结点来简化边界情况的处理。 ","date":"2023-12-19","objectID":"/leetcode%E9%A2%98%E8%A7%A3/:0:2","tags":["题解"],"title":"Leetcode 1，21题 题解","uri":"/leetcode%E9%A2%98%E8%A7%A3/"},{"categories":["微服务"],"content":"使用grpc和net/rpc分别写一个简单的rpc服务","date":"2023-12-14","objectID":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/","tags":["微服务"],"title":"简单的RPC服务demo","uri":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/"},{"categories":["微服务"],"content":"RPC learning ","date":"2023-12-14","objectID":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/:0:0","tags":["微服务"],"title":"简单的RPC服务demo","uri":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/"},{"categories":["微服务"],"content":"一.grpc demo 1.使用proto文件生成go代码: \u0026编写proto文件 //约定语法 syntax = \"proto3\"; //这部分内容是关于最后生成的go文件存在哪个文件目录，. 代表当前项目目录下，server代表最后生成的文件的名字 option go_package = \".;service\"; //service 相当于是go的函数 //service 定义一个服务，客户端可以传入参数，返回服务端的响应 //发送一个HelloRequest 返回一个HelloResponse service SayHello { rpc SayHello(HelloRequest) returns (HelloResponse) {} } //message 相当于是go的结构体， //后面的特殊\"赋值\",代表的是位置顺序,而不是真正的赋值 message HelloRequest{ string requestName = 1; } message HelloResponse{ string responseMessage = 1; } \u0026生成go代码 (记得切换到proto目录下,并注意命令中的空格以及下划线等的符号) protoc --go_out=. hello.proto protoc --go-grpc_out=. hello.proto 2.proto文件介绍： syntax:约定语法 option:这部分内容是关于最后生成的go文件存在哪个文件目录 message ：传输的消息格式的定义 1.字段规则： required:必填字段，protobuf2中使用，protobuf3中删除 optional:可选字段，protobuf3中删去了required和optional，默认optional repeate：可重复字段，重复的值的顺序会被保留到go中重复的会被定义为切片 2.消息号： 也就是看起来像赋值的\"操作\" 每个字段都必须要有的消息号[1,2^29-1]的整数 3.嵌套消息：支持嵌套消息 service:定义一个rpc服务接口 service 服务接口名{ rpc 服务函数名(参数) returns(返回参数){} } 3.服务端编写 package main import ( pb \"RPClearning/hello_server/proto\" \"context\" \"errors\" \"fmt\" \"google.golang.org/grpc\" \"google.golang.org/grpc/metadata\" \"net\" ) type server struct { pb.UnimplementedSayHelloServer } // 业务 func (s *server) SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloResponse, error) { //进行token校验 //获取元数据 注：返回的元数据切片中的所有key都是小写！小写！小写！ md, ok := metadata.FromIncomingContext(ctx) if !ok { return nil, errors.New(\"未传输token\") } var appID string var appKey string if v, ok := md[\"appid\"]; ok { appID = v[0] } if v, ok := md[\"appkey\"]; ok { appKey = v[0] } if appID != \"lance\" || appKey != \"123\" { return \u0026pb.HelloResponse{ResponseMessage: \"token错误 \" + req.RequestName}, nil } fmt.Println(\"hello \" + req.RequestName) return \u0026pb.HelloResponse{ResponseMessage: \"hello \" + req.RequestName}, nil } func main() { //监听端口 listener, _ := net.Listen(\"tcp\", \":9090\") //创建一个grpc服务 grpcServer := grpc.NewServer() //在grpc服务端中注册编写的服务 pb.RegisterSayHelloServer(grpcServer, \u0026server{}) //一定要是引用传递对象 //启动服务 err := grpcServer.Serve(listener) if err != nil { fmt.Printf(\"failed to serve :%v\", \u0026err) return } } 4.客户端编写 package main import ( pb \"RPClearning/hello_server/proto\" \"context\" \"fmt\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials/insecure\" \"log\" ) type ClientToken struct { } func (c ClientToken) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) { return map[string]string{ \"appID\" : \"lance\", \"appKey\": \"123\", }, nil } func (c ClientToken) RequireTransportSecurity() bool { return false //是否带安全验证 } func main() { //连接到server端,此处禁止安全传输 var opts []grpc.DialOption opts = append(opts, grpc.WithTransportCredentials(insecure.NewCredentials())) opts = append(opts, grpc.WithPerRPCCredentials(new(ClientToken))) conn, err := grpc.Dial(\"127.0.0.1:9090\", opts...) if err != nil { log.Fatalf(\"didn't connect :%v\", err) } defer conn.Close() //建立连接 client := pb.NewSayHelloClient(conn) //执行rpc调用（这个方法在服务端来实现，并返回结果） response, _ := client.SayHello(context.Background(), \u0026pb.HelloRequest{RequestName: \"lance\"}) res := response.GetResponseMessage() fmt.Println(\"response:\", res) } ","date":"2023-12-14","objectID":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/:0:1","tags":["微服务"],"title":"简单的RPC服务demo","uri":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/"},{"categories":["微服务"],"content":"二.net/rpc demo 1.服务端代码： package main import ( \"net\" \"net/rpc\" ) type Server struct { } // 通过阅读源码，发现method是有要求的 ： // Method needs three ins: receiver, *args, *reply. // First arg need not be a pointer. // Second arg must be a pointer. // Reply type must be exported. // Method needs one out. // The return type of the method must be error func (s Server) SayHello(args []string, what *string) error { *what = args[0] + \" say hello to \" + args[1] return nil } func main() { //新建一个对象实例 s := new(Server) //注册服务 err := rpc.Register(s) if err != nil { panic(err) } //监听 listener, errs := net.Listen(\"tcp\", \":9090\") if errs != nil { panic(err) } //启动服务 for { conn, err := listener.Accept() if err != nil { continue } go rpc.ServeConn(conn) } } 2.客户端代码 package main import ( \"fmt\" \"net/rpc\" ) var Names = []string{\"lance\", \"longxu\"} var What string func main() { client, err := rpc.Dial(\"tcp\", \"localhost:9090\") must(err) defer client.Close() //err = client.Call(\"Server.SayHello\", Names, \u0026What) //if err != nil { // panic(err) //} // ！！！！注意这里serviceMethod不应该只传入method 而是应该传入object.Method这样的格式,否则会报 service/method request ill-formed的错误 call := \u003c-client.Go(\"Server.SayHello\", Names, \u0026What, make(chan *rpc.Call, 1)).Done fmt.Println(call.ServiceMethod) fmt.Println(call.Reply) fmt.Println(call.Args) fmt.Println(call.Error) if call.Error != nil { panic(err) } fmt.Println(\"rpc调用成功，取得值：\", What) } func must(err error) { if err != nil { panic(err) } } ","date":"2023-12-14","objectID":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/:0:2","tags":["微服务"],"title":"简单的RPC服务demo","uri":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/"},{"categories":["工具"],"content":"如何使用viper配置项目","date":"2023-12-01","objectID":"/viper/","tags":["工具"],"title":"viper:Go语言配置管理神器","uri":"/viper/"},{"categories":["工具"],"content":"viper:Go语言配置管理神器 参考文档：viper 文档汉化：李文周的博客 一.安装 go get github.com/spf13/viper 二.支持特性 1.设置默认值 2.从json ,toml,yaml,hcl,envfile,java properties格式的配置文件读取配置信息 3.实时监控和重新读取配置文件(optional) 4.从环境变量中读取 5.从远程配置系统（etcd和Consul）读取并监控配置变化 6.从命令行参数读取配置 7.从buffer读取配置 8.显示配置值 三.viper可以做什么？ 1.查找，加载和反序列化json,toml,yaml,hcl,ini,envfile,java properties格式的配置文件。 2.提供一种机制为你不同配置选项指定选项的值。 3.提供一种机制来通过命令行参数覆盖指定选项的值。 4.提供别名系统，一边在不破坏现有代码的情况下轻松重命名参数。 5.当用户提供与默认值相同的命令行或配置文件时，可以很容易的分辨出它们之间的区别。 四.viper优先级 (从高到低) 1.显式调用Set设置值 2.命令行参数（flag） 3.环境变量 4.配置文件 5.key/value存储 6.默认值 五.将值存入viper 1.设置默认值： viper.SetDefault(\"name\", \"lance\")//设置name默认值为lance value := viper.GetString(\"name\") //获取默认值 fmt.Println(value)//打印lance 2.读取配置文件： viper可以搜索多个路径，但是目前单个viper实例只支持单个配置文件。 viper不默认任何配置搜索路径，将默认决策留给应用程序。 搜索配置文件： 不需要任何特定的路径，但是至少应该提供一个配置文件预期出现的路径 配置文件有扩展名： viper.SetConfigFile(\"./config.yaml\")//通过指定配置文件路径 配置文件无扩展名 viper.SetConfigName(\"config1\")//配置文件名称（本身就没有扩展名） viper.SetConfigType(\"yaml\")//没有扩展名，必须配置此项 viper.AddConfigPath(\".\")//搜索配置文件所在的路径 viper.AddConfigPath(\"./...\")//多次调用以添加多个搜索路径 ... 读取配置文件： //说明： 这里执行viper.ReadInConfig()之后，viper才能确定到底用哪个文件 err := viper.ReadInConfig() // 查找并读取配置文件 if err != nil { if err == err.(viper.ConfigFileNotFoundError) { panic(err) // 处理找不到配置文件的错误 } panic(err) } 如果有多个同名配置文件，扩展名优先级： json\u003etoml\u003eyaml\u003eyml\u003eproperties(java中的配置文件名)\u003eprops(java中的配置文件名) 3.写入配置文件： 已经预定义路径： //若没有预定义路径会报错 viper.WriteConfig()//覆盖存在的配置文件 viper.SafeWriteConfig()//不会覆盖存在的配置文件，配置文件不存在就创建配置文件 给定路径： viper.WriteConfigAs()//覆盖当前配置文件 viper.SafeWriteConfigAs()//不会覆盖存在的配置文件，配置文件不存在就创建配置文件 4.监控并重新读取配置文件： viper支持在运行时实时读取配置文件的功能 //之前已经添加好了配置路径 viper.WatchConfig() viper.OnConfigChange(func(e fsnotify.Event) { // 配置文件发生变更之后会调用的回调函数 fmt.Println(\"Config file changed:\", e.Name) }) 5.从io.Reader读取配置： 实现自己所需的配置原并将其提供给viper viper.SetConfigFile(\"./config.yaml\") config := []byte(` hello : world ping: pong `) err := viper.ReadConfig(bytes.NewBuffer(config)) if err != nil { panic(err) } //只是读取，未写入配置文件 value := viper.Get(\"ping\") fmt.Println(value) 6.覆盖设置： 这些可能来自命令行标志，也可能来自你自己的应用程序逻辑 viper.Set(\"Verbose\", true) viper.Set(\"LogFile\", LogFile) 7.注册和使用别名： 别名允许多个键引用单个值 viper.RegisterAlias(\"loud\", \"Verbose\") // 注册别名（此处loud和Verbose建立了别名） viper.Set(\"verbose\", true) // 结果与下一行相同 viper.Set(\"loud\", true) // 结果与前一行相同 viper.GetBool(\"loud\") // true viper.GetBool(\"verbose\") // true 8.使用环境变量 9.使用Flags 10.远程Key/Value存储支持 11.监控etcd中的更改-未加密 (以后有待补充) 六.从viper获取值 常用根据值类型获取值的方法： Get(key string) : interface{} GetBool(key string) : bool GetFloat64(key string) : float64 GetInt(key string) : int GetIntSlice(key string) : []int GetString(key string) : string GetStringMap(key string) : map[string]interface{} GetStringMapString(key string) : map[string]string GetStringSlice(key string) : []string GetTime(key string) : time.Time GetDuration(key string) : time.Duration IsSet(key string) : bool //判断键是否存在 AllSettings() : map[string]interface{} 1.访问嵌套的键 访问器方法也接受深度嵌套键的格式化路径。例如，如果加载下面的JSON文件： { \"host\": { \"address\": \"localhost\", \"port\": 5799 }, \"datastore\": { \"metric\": { \"host\": \"127.0.0.1\", \"port\": 3099 }, \"warehouse\": { \"host\": \"198.0.0.1\", \"port\": 2112 } } } viper通过传入 . 分隔的路径来访问嵌套字段： //已经读取了配置文件 viper.GetString(\"datastore.metric.host\")//返回127.0.0.1 如何存在键中包含 \" . “的情况，并且与分隔的键路径匹配，那么返回这个键的值： { \"datastore.metric.host\": \"0.0.0.0\", \"host\": { \"address\": \"localhost\", \"port\": 5799 }, \"datastore\": { \"metric\": { \"host\": \"127.0.0.1\", \"port\": 3099 }, \"warehouse\": { \"host\": \"198.0.0.1\", \"port\": 2112 } } } viper.GetString(\"datastore.metric.host\") // 返回 \"0.0.0.0\" （文档原文）： 这遵守上面建立的优先规则；搜索路径将遍历其余配置注册表，直到找到为止。(译注：因为Viper支持从多种配置来源，例如磁盘上的配置文件\u003e命令行标志位\u003e环境变量\u003e远程Key/Value存储\u003e默认值，我们在查找一个配置的时候如果在当前配置源中没找到，就会继续从后续的配置源查找，直到找到为止。) 例如，在给定此配置文件的情况下，datastore.metric.host和datastore.metric.port均已定义（并且可以被覆盖）。如果另外在默认值中定义了datastore.metric.protocol，Viper也会找到它。 然而，如果datastore.metric被直接赋值覆盖（被flag，环境变量，set()方法等等…），那么datastore.metric的所有子键都将变为未定义状态，它们被高优先级配置级别“遮蔽”（shadowed）了 2.提取子树 还是以上面的配置文件为例： { \"host\": { \"address\": \"localhost\", \"port\": 5799 }, \"datastore\": { \"metric\": { \"host\": \"127.0.0.1\", \"port\": 3","date":"2023-12-01","objectID":"/viper/:0:0","tags":["工具"],"title":"viper:Go语言配置管理神器","uri":"/viper/"},{"categories":["Go"],"content":"go面对对象的简短总结","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/","tags":["Go特性"],"title":"Go的面对对象","uri":"/go%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"},{"categories":["Go"],"content":"Go的面对对象 Go是面向对象的语言吗？ Yes and No. 1.Go允许OO的编程风格 2.Go的struct可以看作其他语言的Class 3.Go缺乏其他语言的继承结构 4.Go的接口与其他语言有很大差异 Go的 “类” 1.其他语言中，往往用class表示一类数据 2.calss的每个实例称作“对象” 3.Go中用struct表示一类数据 4.struct每个实例并不是“对象”，而是此类型的“值” 5.struct也可以定义方法 Go的继承 1.Go并没有继承关系 2.所谓Go的继承只是组合 3.组合中的匿名字段，通过语法糖达成了类似继承的效果 Go的接口 1.接口可以定义Go中的一组行为相似的struct 2.struct并不显式实现接口，而是隐式实现 小结 1.Go没有对象，没有类，没有继承 2.Go通过组合匿名字段来达到类似继承的效果 3.通过以上手段去掉了面对对象中复杂而冗余的部分 4.保留了基本的面对对象特性 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/:0:1","tags":["Go特性"],"title":"Go的面对对象","uri":"/go%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"},{"categories":["数据结构与算法"],"content":"学习笔记","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(一)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/"},{"categories":["数据结构与算法"],"content":"数据结构与算法入门(一) ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/:0:0","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(一)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/"},{"categories":["数据结构与算法"],"content":"第一章：数据结构绪论 1.基本概念与术语 数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。 数据元素：是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 数据项：一个数据元素可以由若干个数据项组成（是数据不可分割的最小单位） 数据对象：是性质相同的数据元素的集合，是数据的子集 数据结构：是相互之间存在的一种或多种特定关系的特定关系的数据元素的集合 2.逻辑结构和物理结构 a.逻辑结构：是指数据对象中数据元素之间的相互关系 集合结构：集合结构中的数据元素除了属于同一个集合外，它们之间没有其他关系 线性结构：线性结构中的数据元素之间是一对一的关系 树形结构：树形结构中的数据元素之间是一对多的层次关系 图形结构：图形结构中的数据元素之间是多对多的关系 b.物理结构：是指数据的逻辑结构在计算机中的存储形式 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的 c.总结： 逻辑结构是面向问题的，物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中 3.抽象数据类型 a.数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称 原子类型：是不可以再分解的基本类型，包括整型，实型，字符型等 结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的 b.抽象数据类型：是指一个数据模型及定义在该模型上的一组操作（体现了程序设计中的问题分解，抽象和信息隐藏的特性） ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/:0:1","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(一)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/"},{"categories":["数据结构与算法"],"content":"第二章：算法 1.定义 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作 2.算法的特性 a.输入输出：算法具有零个或多个输入，至少有一个或多个输出 b.有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成 c.确定性：算法的每一步骤都具有确定的含义，不会出现二义性 d.可行性：算法的每一步骤都具有确定的含义，不会出现二义性 3.算法设计的要求 a.正确性 b.可读性 c.健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果 d.时间效率高和存储量低 4.算法效率的度量方法 a.事后统计方法 b.事前分析估算方法 一个程序的运行时间，依赖于算法的好坏和问题的输入规模，问题输入规模是指输入量的多少 最终，在分析程序的运行时间时，最重要的是把程序看作是独立于程序设计语言的算法或一系列步骤 5.函数的渐近增长 给定两个函数f(n)和g(n)，那么存在一个整数N，使得对于所有的n\u003eN，f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n) 6.算法时间复杂度 算法的时间复杂 度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模 n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐 近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函 数。 推导大O阶： 1．用常数1取代运行时间中的所有加法常数。 2．在修改后的运行次数函数中，只保留最高阶项。 3．如果最高阶项存在且不是1，则去除与这个项相乘的常数。 7.算法空间复杂度 算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂 度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句 关于n所占存储空间的函数。 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/:0:2","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(一)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/"},{"categories":["数据结构与算法"],"content":"第三章：线性表 1.线性表的定义： List：零个或者多个数据元素的有限序列 2.线性表的抽象数据类型定义： ADT 线性表(List) Data 线性表的数据对象集合为{a1, a2, ......, an}，每个元素的类型均为 DataType。 其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。 数据元素之间的关系是一对一的关系。 Operation InitList(*L): 初始化操作，建立一个空的线性表L。 ListEmpty(L): 若线性表为空，返回true，否则返回false。 ClearList(*L): 将线性表清空。 GetElem(L, i, *e): 将线性表L中的第i个位置元素值返回给e。 LocateElem(L, e): 在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功； 3.线性表的顺序存储结构： 顺序存储结构：使用一段地址连续的存储单元依次存储线性表的数据元素 三个属性： 1.存储空间的起始位置：数组data，它的存储位置就是存储空间的 存储位置。 2.线性表的最大存储容量：数组长度MaxSize。 3.线性表的当前长度：length。 #define MAXSIZE 20 typedef int ElemType;//元素类型，看具体情况定，这里使用int typedef struct{ ElemType data[MAXSIZE]; int length; }SqList; 获取元素： //一些状态码 #define OK 1 #define ERROR 0 #define TRUE 1 #define FALSE 0 typedef int Status;//函数类型，其值为函数返回的状态码，如OK等 //初始条件：1\u003c= i \u003c= ListLength(L) Status GetElem(SqList L,int i ,ElemType *e){ if (L.length == 0 ||i \u003c1 || i \u003e L.length ){ return ERROR; } *e = L.data[i - 1]; return OK; } 插入元素： 思路： 如果插入位置不合理，抛出异常； 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量； 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移 动一个位置； 将要插入元素填入位置i处，表长加1。 //初始条件：1\u003c= i \u003c= ListLength(L) //操作结果：L中第i个元素前插入新元素，L的长度+1 Status ListInsert(SqList *L,int i ,ElemType e){ int k ; //判断顺序线性表是否已经满了 if (L-\u003elength == MAXSIZE){ return ERROR; } //判断i是否在范围内 if (i \u003c1 || i \u003e L-\u003elength+1){ return ERROR; } if (i \u003c L-\u003elength){ //将要插入元素后面的元素全部向后移动一位 for (k = L-\u003elength-1;k\u003e=i -1;k--){ L-\u003edata[k+1] = L-\u003edata[k]; } } L -\u003edata[i] = e; L-\u003elength ++; return OK; } 删除操作： 思路： 如果删除位置不合理，抛出异常； 取出删除元素； 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向 前移动一个位置； 表长减1。 //初始条件：1\u003c= i \u003c= ListLength(L) //操作结果：删除L中的第i个元素，并用e返回值，L的长度-1 Status ListDelete(SqList *L,int i , ElemType *e){ int k ; if (L-\u003elength == 0){ return ERROR; } if (i \u003c1 || i \u003eL-\u003elength ){ return ERROR; } *e = L-\u003edata[i-1]; if (i \u003cL-\u003elength){ //将删除的位置后续元素向前推移 for (k= i;k\u003cL-\u003elength;k++){ L-\u003edata[k-1] = L-\u003edata[k]; } } L-\u003elength --; return OK; } 4.线性表的链式存储结构 链式存储结构：用一组任意的存储单元存储线性表的 数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意 味着，这些数据元素可以存在内存未被占用的任意位置 数据域：存储数据元素信息的域 指针域：存储直接后续位置的域，存储的信息称为指针或链 这两部分组成数据元素a(i)的存储映像，称为结点(Node) 头指针：链表中第一个结点的存储位置 为方便操作，会在单链表的第一个结点前附设一个结点，称为头结点 头结点的数据域可以不存任何数据，也可以存储线性表的长度等附加信息 头结点的指针域存储指向第一个结点的指针 我们规定链表最后一个结点指针为“空”（NULL或^） 头指针与头结点的区别： 头指针： 1.头指针是指向链表第一个节点的指针，若链表有头结点，则是指向头结点的指针 2.头指针具有标识作用，所以常用头指针冠以链表的名字 3.无论链表是否为空，头指针均不为空。头指针是链表的必要元素 头结点： 1.头结点是为了操作的统一和方便而设立，放在第一个元素之前，其数据域一般无意义。 2.有了头节点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了 3.头结点不一定是链表必须元素 //单链表的链式存储结构 typedef struct Node{ ElemType data; struct Node *next; }Node; typedef struct Node *LinkList; 获取元素： 获取第i个元素的思路： 1.声明一个指针p指向链表第一个元素，初始化j为1 2.当j\u003ci 时，就遍历链表，让p的指针向后移动，不断指向下一结点，l累加1 3.若到链表末尾P为空，则说明第i个元素不存在 4.若查找成功，返回结点p的数据 //初始条件：1\u003c= i \u003c= ListLength(L) //操作结果：查L中的第i个元素，并用e返回值 Status GetElem(LinkList L,int i , ElemType *e){ int j =1;//j为计数器 LinkList p; p = L-\u003enext; while(p\u0026\u0026j\u003ci){ p = p-\u003enext; ++j; } if (!p || j\u003ei){ return ERROR; } *e =p-\u003edata; return OK; } 元素的插入与删除： 1.插入 核心步骤： s-\u003enext = p-\u003enext ; p-\u003enext = s; 具体实现： //初始条件：1\u003c= i \u003c= ListLength(L) //操作结果：在L中的第i个元素前插入新的数据元素e，L长度+1 Status ListInsert(LinkList *L,int i ,ElemType e){ int j =1 ; LinkList p,s; p = *L; //查找第i-1个元素 while(p\u0026\u0026j \u003c1){ p= p-\u003enext; ++j; } if (!p||j \u003ei){ return ERROR; } //生成新结点(c 标准函数) s = (LinkList)malloc(sizeof(Node)); s-\u003edata= e; //将p的后续结点赋值给s的后续结点 s-\u003enext = p-\u003enext; p-\u003enext = s; return OK; } 2.删除 实际上就是一步： p-\u003enext = p-\u003enext-\u003enext; 具体实现： /* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L) */ /* 操作结果：删除L的第i个结点，并用e返回其 值，L的长度减1 */ Status ListDelete(LinkList *L,int i ,ElemType *e){ int j = 1; LinkList p,q; p = *L; while(p-\u003enext \u0026\u0026j \u003ci){ p = p-\u003enext; ++j; } if (!p-\u003enext || j \u003ei){ return ERROR; } q = p-\u003enext; p-\u003enext = q-\u003enext; *e = q-\u003edata; //系统回收该结点，释放内存 free(q); return OK; } 单链表的整表创建 1.头插法： 思路： 1.声明一个指针p和计数器变量i； 2.初始化一个空链表L； 3.让L的头结点的指针指向NULL，即建立一个带头结点的单链表 4.循环： a.生成一新结点赋值给p； ​ b.随机生成一个数字赋值给p的数据域p-\u003edata; ​ c.将p插入到头结点与前一新节点之间。 实现： /* 随机产生n个元素的值，建立带表头结点的单链 线性表L（头插法） */ void CreateListHead(LinkList *L,int n ){ LinkList p; int i ; //初始化随机数种子 srand(time(0)); *L = (LinkList)malloc(sizeof(Node)); (*L)-\u003enext = NULL; for (i = 0;i\u003cn;i++){ //生成","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/:0:3","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(一)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/"},{"categories":["Go"],"content":"对基本数据类型的源码分析，窥探其底层实现","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"部分基本数据类型的底层实现 基本类型的字节数 1.int大小根据系统字长 2.指针的大小也是系统字长 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:0","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"一.空结构体 1.空结构体的地址均相同（zerobase）（不被包含在其他结构体中） 2.空结构体主要是为了节约内存，内存占用为0 ​ a.结合map：只想要key不要value时，可以将value类型设置为空结构体，实现hashset ​ b.结合channel：只想让channel发一个信号，而不想携带任何信息，可以发一个空结构体，当作纯信号 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:1","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"二.字符串 runtime包对string底层实现： type stringStruct struct { str unsafe.Pointer //指向底层字节数组的指针 len int //字节长度 } ​ reflect包下的StringHeader对string相似底层实现（已被弃用） type StringHeader struct { Data uintptr Len int } 1.字符串本质是个结构体 2.Data指针指向底层的Byte数组 3.len表示Byte数组长度，而不是字符长度 字符串特点 1.字符串是一个不可改变的字节序列，不可修改 2.字符串支持切片操作，不同位置的切片底层访问的是同一块内存数据 3.由于只读的特性，相同字符串面值常量通常对应同一个字符串常量 字符串的访问 1.对字符串使用len方法得到的是字节数而不是字符数 2.对字符串直接使用下标访问，得到的是字节 3.字符串被for range遍历时，被解码成rune类型的字符 4.UTF-8 编码算法位于runtime/utf-8.go Go中的字符编码 1.所有字符使用Unicode字符集 2.使用UTF-8编码 Unicode 1.一种统一的字符集 2.囊括了159种文字的144679个字符 3.14万个字符至少需要3个字节表示 4.英文字母均排在前128个 UTF-8 1.Unicode的一种变长格式 2.128个US-ASCII字符只需要一个字节编码 3.西方常用字符需要两个字节 4.其他字符需要3个字节，极少需要4个字节 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:2","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"四.切片 切片的本质是一个结构体 runtime包对slice的底层实现： type slice struct { array unsafe.Pointer //指向底层数组 len int //切片引用的底层数组的那部分的长度 cap int //底层数组的长度就是切片的容量 } 切片的创建 1.根据数组创建（使用下标） 2.字面量：编译时插入创建数组的代码 示例： go代码 s := []int{3, 2, 1} 汇编代码（截取） 0x000e 00014 (E:/golang/GOPATH/src/GoProgram/main.go:6) LEAQ type:[3]int(SB), AX 0x0015 00021 (E:/golang/GOPATH/src/GoProgram/main.go:6) PCDATA $1, $0 0x0015 00021 (E:/golang/GOPATH/src/GoProgram/main.go:6) CALL runtime.newobject(SB) 0x001a 00026 (E:/golang/GOPATH/src/GoProgram/main.go:6) MOVQ $3, (AX) 0x0021 00033 (E:/golang/GOPATH/src/GoProgram/main.go:6) MOVQ $2, 8(AX) 0x0029 00041 (E:/golang/GOPATH/src/GoProgram/main.go:6) MOVQ $1, 16(AX) 3.make：运行时创建数组 示例 用户代码： s := make([]int) runtime包下的对make创建切片实现： func makeslice(et *_type, len, cap int) unsafe.Pointer { mem, overflow := math.MulUintptr(et.Size_, uintptr(cap)) if overflow || mem \u003e maxAlloc || len \u003c 0 || len \u003e cap { // NOTE: Produce a 'len out of range' error instead of a // 'cap out of range' error when someone does make([]T, bignumber). // 'cap out of range' is true too, but since the cap is only being // supplied implicitly, saying len is clearer. // See golang.org/issue/4085. mem, overflow := math.MulUintptr(et.Size_, uintptr(len)) if overflow || mem \u003e maxAlloc || len \u003c 0 { panicmakeslicelen() } panicmakeslicecap() } return mallocgc(mem, et, true) } 切片的追加 1.不扩容时，只调整len（编译器负责） 2.扩容时，编译时转为调用 runtime.growslice(),使用二倍长的底层数组替代原来的底层数组，废弃原底层数组 3.期望容量大于当前容量的两倍，就会使用期望容量 4.如果当前切片的长度小于1024，将容量翻倍 5.如果当前切片的长度大于1024，每次增加25% 6.切片扩容时，并发不安全，注意切片并发要加锁 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:3","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"五.map map的底层实现是哈希表(散列表)，map的本质是指针，指向一个hmap结构体（A header for a Go map.） hmap中的buckets字段指向bmap结构体（ A bucket for a Go map.），bucket（哈希桶）是map的存储结构 HashMap 的基本方案： 1.开放寻址法 2.拉链法 Go 的map go的map底层结构—–\u003eruntime.hmap: // A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go. // Make sure this stays in sync with the compiler's definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields } buckets 字段(哈希桶)是一个指针，指向一个数组：一个由很多bmap组成的数组 bmap的结构——\u003eruntime.bmap: // A bucket for a Go map. type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] \u003c minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer. } bmap包含的字段： 1.tophash：长度为8的数组，高八位，为了快速遍历 2.data：key和value，一个桶中可以放八个键值对，八个key放一个数组中，八个value放一个数组中 3.overflow：溢出bucket的地址（指向下一个bmap） key，value，overflow都不会显示出来，而是通过maptype计算偏移量获取。因为key，value的数据类型不确定，只有编译的时候才会将八个key和八个value放入哈希桶 extra字段指向mapextra结构体： mapextra结构——-\u003eruntime.mapextra: type mapextra struct { // If both key and elem do not contain pointers and are inline, then we mark bucket // type as containing no pointers. This avoids scanning such maps. // However, bmap.overflow is a pointer. In order to keep overflow buckets // alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow. // overflow and oldoverflow are only used if key and elem do not contain pointers. // overflow contains overflow buckets for hmap.buckets. // oldoverflow contains overflow buckets for hmap.oldbuckets. // The indirection allows to store a pointer to the slice in hiter. overflow *[]*bmap oldoverflow *[]*bmap // nextOverflow holds a pointer to a free overflow bucket. nextOverflow *bmap } nextOverflow字段指向下一个可用的溢出桶 map的初始化 1.make创建： 汇编代码（截取）：可以看到底层调用了runtime.makemap() 0x0020 00032 (E:/golang/GOPATH/src/GoProgram/main.go:8) CALL runtime.makemap(SB) runtime.makemap func makemap(t *maptype, hint int, h *hmap) *hmap { mem, overflow := math.MulUintptr(uintptr(hint), t.Bucket.Size_) if overflow || mem \u003e maxAlloc { hint = 0 } // initialize Hmap if h == nil { h = new(hmap) } h.hash0 = fastrand() // Find the size parameter B which will hold the requested # of elements. // For hint \u003c 0 overLoadFactor returns false since hint \u003c bucketCnt. B := uint8(0) for overLoadFactor(hint, B) { B++ } h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. if h.B != 0 { var nextOverflow *bmap h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) h.extra.nextOverflow = nextOverflow } } return h } 2.字面量 ​ a.元素少于25个时，转化为简单赋值 ​ b.元素多于25个时，转化为循环赋值 map的访问： 计算tophash map的扩容 1.map 溢出桶太多时会导致严重的性能下降 2.runtime.mapassign()可能会触发扩容的情况： ​ a.装载因子超过 6.5（平均每个槽6.5个key） ​ b.使用了太多溢出桶（溢出桶超过了普通桶） map的扩容的类型 1.等量扩容：数据不多但是溢出桶太多了 2.翻倍扩容：数据太多了 扩容步骤一： 1.创建一组新桶 2.oldbuckets指向原有的桶数组 3.bukets指向新的桶数组 4.map标记为扩容状态 扩容步骤二： 1.将所有的数据从旧桶驱逐到新桶 2.采用渐进式驱逐 3.每次操作一个旧桶时，将旧桶数据驱逐到新桶 4.读取时不进行驱逐，只判断读取新桶还是旧桶 扩容步骤三: 1.所有","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:4","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"六.接口 Go隐式接口特点 1.只要实现了接口的全部方法，就是自动实现接口 2.可以在不修改代码的情况下抽象出新的接口 （更加方便系统的扩展和重构） 接口值的底层表示 接口数据使用runtime.iface表示： type iface struct { tab *itab //指向itab结构体，itab结构体中记录了接口类型信息和实现的方法 data unsafe.Pointer //指向底层真实数据 } type itab struct { inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches. _ [4]byte fun [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter. } 类型断言 1.类型断言是一个使用在接口值上的操作 2.可以将接口值转换为其他类型值（实现或者兼容接口) 3.可以配合switch进行类型判断 结构体和结构体指针实现接口 可查看plan9汇编 go build -gcflags -S main.go 在使用结构体实现接口时，编译器会使用结构体指针再实现一遍接口，所以使用结构体和结构体指针进行初始化变量时，都不会报错。 但使用结构体指针实现接口时，编译器不会再用结构体再来实现接口，所以使用结构体初始化变量时会不通过 空接口 1.runtime.eface结构体 type eface struct { _type *_type data unsafe.Pointer } 2.空接口底层不是普通接口 3.空接口值可以承载任何数据 空接口的用途 1.作为任意类型的函数入参 2.函数调用时，会新生成一个新的接口，再传参 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:5","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"nil,空结构体，空接口区别 nil： 是六种类型的零值 每种类型的nil是不同的，无法比较 // nil is a predeclared identifier representing the zero value for a // pointer, channel, func, interface, map, or slice type. var nil Type // Type must be a pointer, channel, func, interface, map, or slice type 空结构体 1.Go中的非常特殊的类型 2.空结构体的值不是nil 3.空结构体的指针也不是nil，但是都相同（zerobase） 空接口 1.空接口不一定是nil接口，（数据是nil，类型不是nil，就不是nil接口) 2.两个属性都是nil才是nil接口 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:6","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"记录对runtime，编译，运行的学习笔记","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"什么是Runtime？ 就是程序的运行环境。 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:0:1","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"Go的Runtime特点： 1.没有虚拟机的概念 2.Runtime作为程序的一部分打包进二进制文件 3.Runtime随用户程序一起运行 4.Runtime与用户程序没有明显界限，直接通过函数调用 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:0:2","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"Go的Runtime能力： 1.内存管理能力 2.垃圾回收能力（GC） 3.超强的并发能力(协程调度) ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:0:3","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"Go的Runtime其他特点： 1.Runtime有一定的屏蔽系统调用能力 2.一些go的关键字其实是Runtime下的函数 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:0:4","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"总结 1.Go的Runtime负责内存管理，垃圾回收，协程调度 2.Go的Runtime被编译为用户程序的一部分，一起运行 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:0:5","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"Go是如何编译的？ ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:1:0","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"编译命令： go build -n ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:1:1","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"编译过程： 词法分析——\u003e句法分析——-\u003e语义分析——-\u003e中间码生成——-\u003e代码优化——-\u003e机器码生成———\u003e链接 词法分析： 1.将源代码分析成Token 2.Token是代码中的最小语义结构 句法分析： 1.Token序列经过处理，变成语法树（抽象语法树ast） 语义分析： 1.类型检查 2.类型推断 3.查看类型是否匹配 4.函数调用内联 5.逃逸分析 中间码生成（SSA） 1.为了处理不同平台的差异，先生成中间代码（SSA） 2.查看从代码到SSA中间码的整个过程 $env:GOSSAFUNC=\"main\" export GOSSAFUNC=main go build 代码优化： 各个步骤都会存在 机器码生成： 1.先生成plan9汇编代码 2.最后编译为机器码 3.输出的机器码为.a文件 4.查看plan9汇编代码： go build -gcflags -S main.go 链接: 将各个包进行链接，包括runtime 总结： 1.编译前端：词法分析，句法分析，语义分析 2.编译后端：中间码生成，代码优化，机器码生成 3.链接 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:1:2","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"Go程序是如何运行的？ A:程序的入口是main方法吗？： 不是的。是runtime包下的rt0_XXX.s(不是go程序，是一个汇编语言) B:运行步骤： 1.读取命令行参数 复制参数数量argc和参数值argv到栈上 2.初始化g0执行栈 a.g0是为了调度协程而产生的协程 b.g0是每个Go程序的第一个协程 3.运行时检测 a.检查各种类型的长度 b.检查指针操作 c.检查结构体字段的偏移量 d.检查atomic原子操作 e.检查CAS操作 f.检查栈大小是否是2的幂次 4.参数初始化 runtime.args a.对命令行中的参数进行处理 b.参数数量赋值给argc int32 c.参数值赋值给argv **byte 5.调度器初始化 runtime.schedinit a.全局栈空间内存分配 b.加载命令行参数到 os.Args c.堆内存空间的初始化 d.加载操作系统环境变量 e.初始化当前系统线程 f.垃圾回收器的参数初始化(GC) g.算法初始化(map,hash) h.设置 process 数量 6.创建主协程 a.创建一个新的协程，执行 runtime.main b.放入调度器等待调度 7.初始化 M a.初始化一个M，用来调度主协程 8.主协程执行主函数 a.执行runtimem 包中的 init 方法 b.启动 GC 垃圾收集器 c.执行用户包依赖的 init 方法 d.执行用户主程序 main.main() (main包中的main函数) C:总结 1.Go 启动时经历了检查，各种初始化，初始化协程调度的过程 2.main.main() 也是在协程中运行的 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:1:3","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["杂事"],"content":"第一篇博客，基于hugo","date":"2023-12-01","objectID":"/first_post/","tags":["杂事"],"title":"first post in hugo","uri":"/first_post/"},{"categories":["杂事"],"content":"Hello world! 将会在这里继续博客的更新 ","date":"2023-12-01","objectID":"/first_post/:0:0","tags":["杂事"],"title":"first post in hugo","uri":"/first_post/"}]