[{"categories":["os"],"content":"哈工大操作系统lab4","date":"2024-04-23","objectID":"/hit_os_lab4/","tags":["lab"],"title":"Hit_os_lab4","uri":"/hit_os_lab4/"},{"categories":["os"],"content":"hit os lab4 ","date":"2024-04-23","objectID":"/hit_os_lab4/:0:0","tags":["lab"],"title":"Hit_os_lab4","uri":"/hit_os_lab4/"},{"categories":["os"],"content":"1.实验内容 现在的 Linux 0.11 采用 TSS（后面会有详细论述）和一条指令就能完成任务切换，虽然简单，但这指令的执行时间却很长，在实现任务切换时大概需要 200 多个时钟周期。 而通过堆栈实现任务切换可能要更快，而且采用堆栈的切换还可以使用指令流水的并行优化技术，同时又使得 CPU 的设计变得简单。所以无论是 Linux 还是 Windows，进程/线程的切换都没有使用 Intel 提供的这种 TSS 切换手段，而都是通过堆栈实现的。 本次实践项目就是将 Linux 0.11 中采用的 TSS 切换部分去掉，取而代之的是基于堆栈的切换程序。具体的说，就是将 Linux 0.11 中的 switch_to 实现去掉，写成一段基于堆栈切换的代码。 本次实验包括如下内容： 编写汇编程序 switch_to： 完成主体框架； 在主体框架下依次完成 PCB 切换、内核栈切换、LDT 切换等； 修改 fork()，由于是基于内核栈的切换，所以进程需要创建出能完成内核栈切换的样子。 修改 PCB，即 task_struct 结构，增加相应的内容域，同时处理由于修改了 task_struct 所造成的影响。 用修改后的 Linux 0.11 仍然可以启动、可以正常使用。 （选做）分析实验 3 的日志体会修改前后系统运行的差别。 ","date":"2024-04-23","objectID":"/hit_os_lab4/:0:1","tags":["lab"],"title":"Hit_os_lab4","uri":"/hit_os_lab4/"},{"categories":["os"],"content":"2.实验原理 内核线程switch_to五段论 中断进入阶段 调用schedule引起PCB切换 切换内核栈 中断返回前 中断返回 TSS切换 根据TR寄存器中的段描述符在GDT表中，找到当前进程的TSS段 将CPU中所有的寄存器信息保存到该内存地址 再根据目标进程的段描述符，在GDT表中找到目标进程的TSS段，再将该段信息“扣”到CPU上，就完成了进程切换 switch_to(linux/sched.h): #define switch_to(n) {\\ struct {long a,b;} __tmp; \\ __asm__(\"cmpl %%ecx,current\\n\\t\" \\ \"je 1f\\n\\t\" \\ \"movw %%dx,%1\\n\\t\" \\ \"xchgl %%ecx,current\\n\\t\" \\ \"ljmp *%0\\n\\t\" \\ //实际上switch_to就是一句ljmp指令 \"cmpl %%ecx,last_task_used_math\\n\\t\" \\ \"jne 1f\\n\\t\" \\ \"clts\\n\" \\ \"1:\" \\ ::\"m\" (*\u0026__tmp.a),\"m\" (*\u0026__tmp.b), \\ \"d\" (_TSS(n)),\"c\" ((long) task[n])); \\ } #define _TSS(n) ((((unsigned long) n)\u003c\u003c4)+(FIRST_TSS_ENTRY\u003c\u003c3)) #define FIRST_TSS_ENTRY 4 ","date":"2024-04-23","objectID":"/hit_os_lab4/:0:2","tags":["lab"],"title":"Hit_os_lab4","uri":"/hit_os_lab4/"},{"categories":["os"],"content":"3.实验开始 1.修改switch_to相关 ​ 因为切换进程不再需要TSS进行切换了，而是采用内核栈切换的方式来进行切换，所以在新的switch_to需要当前进程的PCB，目标进程的PCB，当前进程的内核栈，目标进程的内核栈等信息。 内核栈信息与PCB位于同一页内存中，所以当知道PCB就可以获得内核栈信息，而当前进程的PCB位于全局变量current中，所以仅需要传递给switch_to目标进程的PCB指针。虽然不需要TSS(next)了，但是还需要_LDT(next)，所以还要传递一个_LDT(next)，每个进程都会有一个LDT，LDT是一个映射表，防止符号地址错乱。 对sched.c作出修改： void schedule(void) { int i,next,c; struct task_struct ** p; ... while (1) { ... while (--i) { if (!*--p) continue; if ((*p)-\u003estate == TASK_RUNNING \u0026\u0026 (*p)-\u003ecounter \u003e c) c = (*p)-\u003ecounter, next = i; } ... } switch_to(next); } 改为 sturct tss_struct * tss = \u0026(init_task.task.tss) //0 号进程的 tss，所有进程都共用这个 tss，任务切换时不再发生变化。 ... extern void switch_to(struct task_struct*,int ); void schedule(void) { int i,next,c; struct task_struct ** p; struct task_struct * pnext = \u0026(init_task.task); //表示下一个进程的相关信息 while (1) { c = -1; next = 0; while (--i) { if (!*--p) continue; if ((*p)-\u003estate == TASK_RUNNING \u0026\u0026 (*p)-\u003ecounter \u003e c) c = (*p)-\u003ecounter, next = i,pnext=*p; } } switch_to(pnext,_LDT(next)); } switch_to依次主要完成如下功能： 先处理栈帧，即处理ebp寄存器 取出下一个进程参数，并和current比较，相等就什么也不做，不等就开始进程切换 进程开始切换： PCB切换 TSS内核栈指针重写 内核栈切换 LDT切换 PC指针(CS:EIP)切换 这里引用实验手册原话： ​ 关于 PC 的切换，和前面论述的一致，依靠的就是 switch_to 的最后一句指令 ret，虽然简单，但背后发生的事却很多：schedule() 函数的最后调用了这个 switch_to 函数，所以这句指令 ret 就返回到下一个进程（目标进程）的 schedule() 函数的末尾，遇到的是}，继续 ret 回到调用的 schedule() 地方，是在中断处理中调用的，所以回到了中断处理中，就到了中断返回的地址，再调用 iret 就到了目标进程的用户态程序去执行，和书中论述的内核态线程切换的五段论是完全一致的。 ​ first_return_from_kernel要完成什么工作？PCB 切换完成、内核栈切换完成、LDT 切换完成，接下来应该那个“内核级线程切换五段论”中的最后一段切换了，即完成用户栈和用户代码的切换，依靠的核心指令就是 iret，当然在切换之前应该回复一下执行现场，主要就是eax,ebx,ecx,edx,esi,edi,gs,fs,es,ds等寄存器的恢复 然后是修改sched.h: struct task_struct { /* these are hardcoded - don't touch */ long state; /* -1 unrunnable, 0 runnable, \u003e0 stopped */ long counter; long priority; long kernelstack //在这里新增，所以signal，sigactioin,blocked在刚刚的syscall.s中也要修改 long signal; struct sigaction sigaction[32]; long blocked; /* bitmap of masked signals */ /* various fields */ }; ... #define INIT_TASK \\ /* state etc */ { 0,15,15,PAGE_SIZE+(long)\u0026init_task, \\ //为新增的kernelstack初始化 /* signals */ 0,{{},},0, \\ ... } ... //删除掉原来的switch_to 2.修改fork相关 就是将进程的用户栈，内核栈，用户程序通过压入内核栈中的ss:esp,cs:eip相关联 int copy_process(int nr,long ebp,long edi,long esi,long gs,long none, long ebx,long ecx,long edx, long fs,long es,long ds, long eip,long cs,long eflags,long esp,long ss) { struct task_struct *p; int i; struct file *f; p = (struct task_struct *) get_free_page(); if (!p) return -EAGAIN; task[nr] = p; *p = *current; /* NOTE! this doesn't copy the supervisor stack */ p-\u003estate = TASK_UNINTERRUPTIBLE; p-\u003epid = last_pid; p-\u003efather = current-\u003epid; p-\u003ecounter = p-\u003epriority; p-\u003esignal = 0; p-\u003ealarm = 0; p-\u003eleader = 0; /* process leadership doesn't inherit */ p-\u003eutime = p-\u003estime = 0; p-\u003ecutime = p-\u003ecstime = 0; p-\u003estart_time = jiffies; //tss相关部分全部删除 krnstack = (long *) (PAGE_SIZE + (long) p); *(--krnstack) = ss \u0026 0xffff; *(--krnstack) = esp; *(--krnstack) = eflags; *(--krnstack) = cs \u0026 0xffff; *(--krnstack) = eip; *(--krnstack) = ds \u0026 0xffff; *(--krnstack) = es \u0026 0xffff; *(--krnstack) = fs \u0026 0xffff; *(--krnstack) = gs \u0026 0xffff; *(--krnstack) = esi; *(--krnstack) = edi; *(--krnstack) = edx; *(--krnstack) = (long) first_return_from_kernel; //初始化地址，switch_to的ret就会跳转到first_return_form_kernel的地方 //为了完成switch_to最后的弹栈 *(--krnstack) = ebp; *(--krnstack) = ecx; *(--krnstack) = ebx; // 这里的 0 最有意思。 *(--krnstack) = 0; p-\u003ekernelstack = stack; if (last_task_used_math == current) __asm__(\"clts ; fnsave %0\"::\"m\" (p-\u003etss.i387)); if (copy_mem(nr,p)) { task[nr] = NULL; free_page((long) p); return -EAGAIN; } for (i=0; i\u003cNR_OPEN;i++) if ((f=p-\u003efilp[i])) f-\u003ef_count++; if (current-\u003epwd) current-\u003epwd-\u003ei_count++; if (current-\u003eroot) current-\u003eroot-\u003ei_count++; if (current-\u003eexecutable) current-\u003eexecutable-\u003ei_count++; set_tss_desc(gdt+(nr\u003c\u003c1)+FIRST_TSS_ENTRY,\u0026(p-\u003etss)); set_ldt_desc(gdt+(nr\u003c\u003c1)+FIRST_LDT_ENTRY,\u0026(p-\u003eldt)); p-\u003estate = TASK_RUNNING; /* do this last, just in case */ return last_pid; } fork会调用first_return_form_kernel,所以还需要添加： extern void first_return_from_kernel(","date":"2024-04-23","objectID":"/hit_os_lab4/:0:3","tags":["lab"],"title":"Hit_os_lab4","uri":"/hit_os_lab4/"},{"categories":["os"],"content":"4.回答问题 回答下面三个题： 问题 1 针对下面的代码片段： movl tss,%ecx addl $4096,%ebx movl %ebx,ESP0(%ecx) 回答问题： （1）为什么要加 4096； 参考答案：因为ebx为下一个进程的task_struct指针，内核栈栈顶需要设置为与该进程task_struct相同物理页页顶，一页为4k(4096); （2）为什么没有设置 tss 中的 ss0。 参考答案：所有进程的SS0都是0x10，切换前后不改变，所以不需要设置 问题 2 针对代码片段： *(--krnstack) = ebp; *(--krnstack) = ecx; *(--krnstack) = ebx; *(--krnstack) = 0; 回答问题： （1）子进程第一次执行时，eax=？为什么要等于这个数？哪里的工作让 eax 等于这样一个数？ 答：eax=0，为了区分子进程和父进程的区别，注意修改后的fork.c中*(--krnstack) = 0;，这里将eax赋值为0。 （2）这段代码中的 ebx 和 ecx 来自哪里，是什么含义，为什么要通过这些代码将其写到子进程的内核栈中？ 答：来自父进程在调用fork系统调用时传递进来的参数，即是通过system_call压入了内核栈，为了使子进程完全拷贝父进程的信息。通过在fork函数中写入到子进程的内核栈中，顺序不能发生变化，因为在进程切换时，由switch_to等函数弹出内核栈，必须与pop的顺序严格对应。 （3）这段代码中的 ebp 来自哪里，是什么含义，为什么要做这样的设置？可以不设置吗？为什么？ 答：来自于父进程调用fork系统调用传递进来的参数，是父进程fork函数栈帧的基指针。因为在switch_to中设置了ebp的pop，所以必须设置，如果switch_to不pop，就可以不设置。 问题 3 为什么要在切换完 LDT 之后要重新设置 fs=0x17？而且为什么重设操作要出现在切换完 LDT 之后，出现在 LDT 之前又会怎么样？ 难懂，跳过， ","date":"2024-04-23","objectID":"/hit_os_lab4/:0:4","tags":["lab"],"title":"Hit_os_lab4","uri":"/hit_os_lab4/"},{"categories":["os"],"content":"5.总结 参考博客：哈工大操作系统实验四——基于内核栈切换的进程切换（极其详细） 这个lab是我目前来说做过最难的一个lab，基本上都是参考其他优秀博客，很多晦涩难懂的概念以及过程。对于基于内核栈切换线程的基本流程了解了个大概，应该会在之后写小内核会再深入理解一下。 ","date":"2024-04-23","objectID":"/hit_os_lab4/:0:5","tags":["lab"],"title":"Hit_os_lab4","uri":"/hit_os_lab4/"},{"categories":["os"],"content":"哈工大操作系统lab3","date":"2024-04-17","objectID":"/hit_os_lab3/","tags":["lab"],"title":"Hit_os_lab3","uri":"/hit_os_lab3/"},{"categories":["os"],"content":"hit os lab3 ","date":"2024-04-17","objectID":"/hit_os_lab3/:0:0","tags":["lab"],"title":"Hit_os_lab3","uri":"/hit_os_lab3/"},{"categories":["os"],"content":"1.实验内容 进程从创建（Linux 下调用 fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出 CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行…… 本次实验包括如下内容： 基于模板 process.c 编写多进程的样本程序，实现如下功能： + 所有子进程都并行运行，每个子进程的实际运行时间一般不超过 30 秒； + 父进程向标准输出打印所有子进程的 id，并在所有子进程都退出后才退出； 在 Linux0.11 上实现进程运行轨迹的跟踪。 + 基本任务是在内核中维护一个日志文件 /var/process.log，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一 log 文件中。 在修改过的 0.11 上运行样本程序，通过分析 log 文件，统计该程序建立的所有进程的等待时间、完成时间（周转时间）和运行时间，然后计算平均等待时间，平均完成时间和吞吐量。可以自己编写统计程序，也可以使用 python 脚本程序—— stat_log.py（在 /home/teacher/ 目录下） ——进行统计。 修改 0.11 进程调度的时间片，然后再运行同样的样本程序，统计同样的时间数据，和原有的情况对比，体会不同时间片带来的差异。 /var/process.log 文件的格式必须为： pid X time 其中： pid 是进程的 ID； X 可以是 N、J、R、W 和 E 中的任意一个，分别表示进程新建(N)、进入就绪态(J)、进入运行态(R)、进入阻塞态(W) 和退出(E)； time 表示 X 发生的时间。这个时间不是物理时间，而是系统的滴答时间(tick)； 三个字段之间用制表符分隔。例如： 12 N 1056 12 J 1057 4 W 1057 12 R 1057 13 N 1058 13 J 1059 14 N 1059 14 J 1060 15 N 1060 15 J 1061 12 W 1061 15 R 1061 15 J 1076 14 R 1076 14 E 1076 ...... 完成实验后，在实验报告中回答如下问题： 结合自己的体会，谈谈从程序设计者的角度看，单进程编程和多进程编程最大的区别是什么？ 你是如何修改时间片的？仅针对样本程序建立的进程，在修改时间片前后，log 文件的统计结果（不包括 Graphic）都是什么样？结合你的修改分析一下为什么会这样变化，或者为什么没变化？ ","date":"2024-04-17","objectID":"/hit_os_lab3/:0:1","tags":["lab"],"title":"Hit_os_lab3","uri":"/hit_os_lab3/"},{"categories":["os"],"content":"2.实验开始 1.编写process.c ... #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e int main(){ pid_t id1; pid_t id2; pid_t id3; id1 = fork(); if (id1 \u003c 0 ){ printf(\"error\"); }else if (id1 == 0 ){ printf(\"child 1 \\n\"); cpuio_bound(5, 0, 4); } id2 = fork(); if (id2 \u003c 0 ){ printf(\"error\"); }else if (id2 == 0 ){ printf(\"child 2 \\n\"); cpuio_bound(5, 2, 2); } id3 = fork(); if (id3 \u003c 0 ){ printf(\"error\"); }else if (id3 == 0 ){ printf(\"child 3 \\n\"); cpuio_bound(5, 4, 0); } printf(\"process id : %d\\n\",getpid()); printf(\"child1 :%d\\n\",id1); printf(\"child2 :%d\\n\",id2); printf(\"child3 :%d\\n\",id3); wait(NULL); wait(NULL); wait(NULL); return 0; } ... 2.打开log文件 修改init/main.c,使操作系统启动时就能打开process.log文件,且已经加载文件系统和对应文件描述符(stdin,stdout,stderr) 将init函数中的这部分移动到main函数中 setup((void *) \u0026drive_info); //加载文件系统 (void) open(\"/dev/tty0\",O_RDWR,0); //打开/dev/tty0,让文件描述符0与之关联 (void) dup(0); //让文件描述符1与之关联 (void) dup(0); //让文件描述符2与之关联 像这样,再加上打开process.log文件的函数 move_to_user_mode(); setup((void *) \u0026drive_info); (void) open(\"/dev/tty0\",O_RDWR,0); (void) dup(0); (void) dup(0); (void) open(\"/var/process.log\",O_CREAT|O_TRUNC|O_WRONLY,0666); if (!fork()) { /* we count on this going ok */ init(); } 3.写log文件 根据实验手册指示，内核中无法使用write函数，考虑难度，手册直接给出了内核中可以使用的源码，放入到kernel/printk.c中： #include \"linux/sched.h\" #include \"sys/stat.h\" static char logbuf[1024]; int fprintk(int fd, const char *fmt, ...) { va_list args; int count; struct file * file; struct m_inode * inode; va_start(args, fmt); count=vsprintf(logbuf, fmt, args); va_end(args); /* 如果输出到stdout或stderr，直接调用sys_write即可 */ if (fd \u003c 3) { __asm__(\"push %%fs\\n\\t\" \"push %%ds\\n\\t\" \"pop %%fs\\n\\t\" \"pushl %0\\n\\t\" /* 注意对于Windows环境来说，是_logbuf,下同 */ \"pushl $logbuf\\n\\t\" \"pushl %1\\n\\t\" /* 注意对于Windows环境来说，是_sys_write,下同 */ \"call sys_write\\n\\t\" \"addl $8,%%esp\\n\\t\" \"popl %0\\n\\t\" \"pop %%fs\" ::\"r\" (count),\"r\" (fd):\"ax\",\"cx\",\"dx\"); } else /* 假定\u003e=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/ { /* 从进程0的文件描述符表中得到文件句柄 */ if (!(file=task[0]-\u003efilp[fd])) return 0; inode=file-\u003ef_inode; __asm__(\"push %%fs\\n\\t\" \"push %%ds\\n\\t\" \"pop %%fs\\n\\t\" \"pushl %0\\n\\t\" \"pushl $logbuf\\n\\t\" \"pushl %1\\n\\t\" \"pushl %2\\n\\t\" \"call file_write\\n\\t\" \"addl $12,%%esp\\n\\t\" \"popl %0\\n\\t\" \"pop %%fs\" ::\"r\" (count),\"r\" (file),\"r\" (inode):\"ax\",\"cx\",\"dx\"); } return count; } 记得在kernel.h中添加该函数定义,注意之后使用该内核函数需要将kernel.h加入到文件中： int fprintk(int fd, const char *fmt, ...) 4.添加写log的代码 主要是对于这五个状态N,J,W,R,E,统一都是 fprintk(3,\"%d\\t?\\t%d\\n\",(*p)-\u003epid,jiffies); //针对性的改变字符串中的?,改为对应对状态字符 1.修改fork.c: 将copy_process ... p-\u003estart_time = jiffies; //这里进程开始运行 ... p-\u003estate = TASK_RUNNING; //进程设置为就绪态 改为 ... p-\u003estart_time = jiffies; //这里进程开始运行 fprintk(3,\"%d\\tN\\t%d\\n\",p-\u003epid,jiffies); ... p-\u003estate = TASK_RUNNING; //进程设置为就绪态 fprintk(3,\"%d\\tJ\\t%d\\n\",p-\u003epid,jiffies); 2.修改sched.c 将schedule改为 void schedule(void) { int i,next,c; struct task_struct ** p; /* check alarm, wake up any interruptible tasks that have got a signal */ for(p = \u0026LAST_TASK ; p \u003e \u0026FIRST_TASK ; --p) if (*p) { if ((*p)-\u003ealarm \u0026\u0026 (*p)-\u003ealarm \u003c jiffies) { (*p)-\u003esignal |= (1\u003c\u003c(SIGALRM-1)); (*p)-\u003ealarm = 0; } if (((*p)-\u003esignal \u0026 ~(_BLOCKABLE \u0026 (*p)-\u003eblocked)) \u0026\u0026 (*p)-\u003estate==TASK_INTERRUPTIBLE){ (*p)-\u003estate=TASK_RUNNING; fprintk(3,\"%d\\tJ\\t%d\\n\",(*p)-\u003epid,jiffies); //在这里添加一个就绪态的记录 } } /* this is the scheduler proper: */ while (1) { c = -1; next = 0; i = NR_TASKS; p = \u0026task[NR_TASKS]; while (--i) { if (!*--p) continue; if ((*p)-\u003estate == TASK_RUNNING \u0026\u0026 (*p)-\u003ecounter \u003e c) c = (*p)-\u003ecounter, next = i; } if (c) break; for(p = \u0026LAST_TASK ; p \u003e \u0026FIRST_TASK ; --p) if (*p) (*p)-\u003ecounter = ((*p)-\u003ecounter \u003e\u003e 1) + (*p)-\u003epriority; } //!!!这部分是新增，参考别人的博客， /* 实验手册提示：schedule() 找到的 next 进程是接下来要运行的进程（注意，一定要分析清楚 next 是什么）。如果 next 恰好是当前正处于运行态的进程，swith_to(next) 也会被调用。这种情况下相当于当前进程的状态没变。 */ if(current-\u003epid != task[next] -\u003epid) { if(current-\u003estate == TASK_RUNNING) fprintk(3,\"%d\\tJ\\t%d\\n\",current-\u003epid,jiffies); fprintk(3,\"%d\\tR\\t%d\\n\",task[next]-\u003epid,jiffies); } //!!! switch_to(next); } 将syspause current-\u003estate = TASK_INTERRUPTIBLE; ... 改为 current-\u003estate = TASK_INTERRUPTIBLE; fprintk(3,\"%d\\tW\\t%d\\n\",curr","date":"2024-04-17","objectID":"/hit_os_lab3/:0:2","tags":["lab"],"title":"Hit_os_lab3","uri":"/hit_os_lab3/"},{"categories":["os"],"content":"3.总结 这个实验主要是重头在于分析fork.c,sched.c,exit.c中那些地方对进程状态做出来改变，然后在改变的时候进行对log文件的写入，这些写入的位置参考，修改时间片的部分就不做了。 ","date":"2024-04-17","objectID":"/hit_os_lab3/:0:3","tags":["lab"],"title":"Hit_os_lab3","uri":"/hit_os_lab3/"},{"categories":["os"],"content":"哈工大操作系统lab2","date":"2024-04-15","objectID":"/hit_os_lab2/","tags":["lab"],"title":"Hit_os_lab2","uri":"/hit_os_lab2/"},{"categories":["os"],"content":"hit os lab2 ","date":"2024-04-15","objectID":"/hit_os_lab2/:0:0","tags":["lab"],"title":"Hit_os_lab2","uri":"/hit_os_lab2/"},{"categories":["os"],"content":"1.实验内容 此次实验的基本内容是：在 Linux 0.11 上添加两个系统调用，并编写两个简单的应用程序测试它们。 （1）iam() 第一个系统调用是 iam()，其原型为： int iam(const char * name); 完成的功能是将字符串参数 name 的内容拷贝到内核中保存下来。要求 name 的长度不能超过 23 个字符。返回值是拷贝的字符数。如果 name 的字符个数超过了 23，则返回 “-1”，并置 errno 为 EINVAL。 在 kernal/who.c 中实现此系统调用。 （2）whoami() 第二个系统调用是 whoami()，其原型为： int whoami(char* name, unsigned int size); 它将内核中由 iam() 保存的名字拷贝到 name 指向的用户地址空间中，同时确保不会对 name 越界访存（name 的大小由 size 说明）。返回值是拷贝的字符数。如果 size 小于需要的空间，则返回“-1”，并置 errno 为 EINVAL。 也是在 kernal/who.c 中实现。 （3）测试程序 运行添加过新系统调用的 Linux 0.11，在其环境下编写两个测试程序 iam.c 和 whoami.c。最终的运行结果是： $ ./iam lizhijun $ ./whoami lizhijun （4）在实验报告中回答如下问题： 从 Linux 0.11 现在的机制看，它的系统调用最多能传递几个参数？你能想出办法来扩大这个限制吗？ 用文字简要描述向 Linux 0.11 添加一个系统调用 foo() 的步骤。 ","date":"2024-04-15","objectID":"/hit_os_lab2/:0:1","tags":["lab"],"title":"Hit_os_lab2","uri":"/hit_os_lab2/"},{"categories":["os"],"content":"2.系统调用原理 系统调用流程： 应用程序调用库函数（API） API把系统调用号传给EAX，中断调用进入内核态 中断处理函数通过系统调用号，调用对应内核函数（系统调用） 系统调用结束后，将返回值存入EAX，返回到中断处理函数 中断处理函数返回到API API将EAX返回给应用程序 1.以write为例来分析系统调用实现： write.c: #define __LIBRARY__ #include \u003cunistd.h\u003e _syscall3(int,write,int,fd,const char *,buf,off_t,count) unistd.h(截取关于write): #define __NR_write 4 #define _syscall3(type,name,atype,a,btype,b,ctype,c) \\ type name(atype a,btype b,ctype c) \\ { \\ long __res; \\ __asm__ volatile (\"int $0x80\" \\ : \"=a\" (__res) \\ : \"0\" (__NR_##name),\"b\" ((long)(a)),\"c\" ((long)(b)),\"d\" ((long)(c))); \\ if (__res\u003e=0) \\ return (type) __res; \\ errno=-__res; \\ return -1; \\ } int write(int fildes, const char * buf, off_t count); 可以看到write是通过宏来展开成一段包含int中断的汇编代码，在这个宏中：type对应int，name对应write，atype对应int，a对应fd，btype对应const char * ，b对应buf，ctype对应off_t，c对应count。当宏展开后与下面这句代码向对应： int write(int fildes, const char * buf, off_t count); 在宏中，定义了返回值_res,然后是一段内嵌汇编，进行int 0x80中断调用。下一句是将EAX赋给__res，也就是通过将返回值放在EAX中进行返回。下一句的0指的依旧是EAX，name对应write，合起来就是 _ _ NR_write ，也就是把write的系统调用号4置给EAX。之后的就是将另外三个参数分别传给EBX，ECX，EDX，这三个传入参数也对应着syscall3的3。 2.在内核中的write函数 是通过int 0x80进行中断处理函数，通过系统调用号来调用这个函数 read_write.c: int sys_write(unsigned int fd,char * buf,int count) { struct file * file; struct m_inode * inode; if (fd\u003e=NR_OPEN || count \u003c0 || !(file=current-\u003efilp[fd])) return -EINVAL; if (!count) return 0; inode=file-\u003ef_inode; if (inode-\u003ei_pipe) return (file-\u003ef_mode\u00262)?write_pipe(inode,buf,count):-EIO; if (S_ISCHR(inode-\u003ei_mode)) return rw_char(WRITE,inode-\u003ei_zone[0],buf,count,\u0026file-\u003ef_pos); if (S_ISBLK(inode-\u003ei_mode)) return block_write(inode-\u003ei_zone[0],\u0026file-\u003ef_pos,buf,count); if (S_ISREG(inode-\u003ei_mode)) return file_write(inode,file,buf,count); printk(\"(Write)inode-\u003ei_mode=%06o\\n\\r\",inode-\u003ei_mode); return -EINVAL; } 3.让我们看看0x80中断的处理： 这个函数就是在操作系统启动的时候就初始化好了，也就是设置好了0x80的中断处理 void sched_init(void) { //省略无关部分，这里可以看到int 0x80是执行system_call中断处理函数 set_system_gate(0x80,\u0026system_call); } 下面这段代码就是设置好idt表，将0x80的中断号对应system_call中断处理函数的地址。同时这里也可以看到dpl被设置为了3 #define set_system_gate(n,addr) \\ _set_gate(\u0026idt[n],15,3,addr) #define _set_gate(gate_addr,type,dpl,addr) \\ __asm__ (\"movw %%dx,%%ax\\n\\t\" \\ \"movw %0,%%dx\\n\\t\" \\ \"movl %%eax,%1\\n\\t\" \\ \"movl %%edx,%2\" \\ : \\ : \"i\" ((short) (0x8000+(dpl\u003c\u003c13)+(type\u003c\u003c8))), \\ \"o\" (*((char *) (gate_addr))), \\ \"o\" (*(4+(char *) (gate_addr))), \\ \"d\" ((char *) (addr)),\"a\" (0x00080000)) 下面就是int 0x80的中断处理函数 system_call: cmpl $nr_system_calls-1,%eax ja bad_sys_call push %ds push %es push %fs pushl %edx pushl %ecx # push %ebx,%ecx,%edx as parameters pushl %ebx # to the system call movl $0x10,%edx # set up ds,es to kernel space mov %dx,%ds mov %dx,%es movl $0x17,%edx # fs points to local data space mov %dx,%fs call sys_call_table(,%eax,4) pushl %eax movl current,%eax cmpl $0,state(%eax) # state jne reschedule cmpl $0,counter(%eax) # counter je reschedule 着重看一下 **call sys_call_table(,%eax,4) ** 这句意思就是跳转到sys_call_table的地址+EAX*4，而EAX的值也就是通过最最开始的库函数传递给EAX的系统调用号。为什么是4呢，因为每个系统调用的函数占四个字节，因此可以知道sys_call_table是一个函数表。 那么我们接着看看这个sys_call_table： //sched.h typedef int (*fn_ptr)(); //sys.h fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read, sys_write,... }; 与前面write调用号为4，完全对应。 ","date":"2024-04-15","objectID":"/hit_os_lab2/:0:2","tags":["lab"],"title":"Hit_os_lab2","uri":"/hit_os_lab2/"},{"categories":["os"],"content":"3.实验开始 1.添加iam和whoami系统调用号和库函数 unistd.h 坑：需要修改虚拟机的unistd.h相同的地方，否则后面的gcc无法成功编译文件 #define __NR_iam 72 #define __NR_whoami 73 int iam(const char * name); int whoami(char* name ,unsigned int size); 2.在sys_call_table中添加系统调用函数 sys.h extern int sys_iam(); extern int sys_whoami(); fn_ptr sys_call_table[] = { ... ,sys_iam,sys_whoami}; 3.修改系统调用函数数量 system_call.s nr_system_calls = 74 4.编写系统调用函数 kernel/who.c #include\u003cerrno.h\u003e //错误代码 #include\u003cstring.h\u003e //字符串操作 #include\u003casm/segment.h\u003e //用于提供get_fs_byte和put_fs_byte char data[24]; int sys_iam(const char* name){ int i = 0 ; char temp[26]; for (;i\u003c26;i++){ temp[i] = get_fs_byte(name+i); if (temp[i] == '\\0') break; } if (i \u003e size) return -(EINVAL); strcpy(data,temp); return i; } int sys_whoami(char * name,unsigned int size){ int i = 0 ; while (data[i] != '\\0') i++; if (i \u003esize) return -(EINVAL); i = 0; for (;i\u003csize;i++){ put_fs_byte(data[i],name+i); if (data[i] == '\\0') break; } return i; } 5.修改makefile 参考实验手册 第一处 OBJS = sched.o system_call.o traps.o asm.o fork.o \\ panic.o printk.o vsprintf.o sys.o exit.o \\ signal.o mktime.o 改为 OBJS = sched.o system_call.o traps.o asm.o fork.o \\ panic.o printk.o vsprintf.o sys.o exit.o \\ signal.o mktime.o who.o 第二处 ### Dependencies: exit.s exit.o: exit.c ../include/errno.h ../include/signal.h \\ ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \\ ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \\ ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \\ ../include/asm/segment.h 改成 ### Dependencies: who.s who.o: who.c ../include/linux/kernel.h ../include/unistd.h exit.s exit.o: exit.c ../include/errno.h ../include/signal.h \\ ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \\ ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \\ ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \\ ../include/asm/segment.h 6.重新编译 make all 7.在虚拟机中新增iam.c和whoami.c文件 参考 sudo ./mount-hdc cd ./hdc/usr/root 创建iam.c #define __LIBRARY__ #include \u003cunistd.h\u003e _syscall1(int,iam,const char*,name); int main(int argc,char* argv[]) { iam(argv[1]); return 0; } 创建whoami.c文件 #define __LIBRARY__ #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e _syscall2(int, whoami, char*, name, unsigned int, size); int main(int argc, char ** argv) { char t[30]; whoami(t, 30); printf(\"%s\\n\", t); return 0; } 8.在虚拟机中添加测试文件 (关闭虚拟机文件系统时，要记得切换到非虚拟机文件，否则会损坏文件系统) cd ~/oslab sudo ./mount-hdc cd ./hdc/usr/root cp /home/teacher/testlab2.c ./ cp /home/teacher/testlab2.sh ./ 9.开始测试 gcc -o iam iam.c gcc -o whoami whoami.c gcc -o testlab2 testlab2.c ./iam lance ./whoami //返回lance ./testlab2 ./testlab2.sh 实验成功。。。 10.回答实验报告中的问题 从 Linux 0.11 现在的机制看，它的系统调用最多能传递几个参数？你能想出办法来扩大这个限制吗？ 最多传递三个参数，也就是unistd.h中定义的那几个_syscalln宏定义，n最大为三，可以再定义更多参数的宏定义来扩大限制，但是也会收到寄存器数量限制。 用文字简要描述向 Linux 0.11 添加一个系统调用 foo() 的步骤。 添加foo的系统调用号 编写foo系统调用函数 将系统调用函数添加到sys_call_table中 修改相应Makefile ","date":"2024-04-15","objectID":"/hit_os_lab2/:0:3","tags":["lab"],"title":"Hit_os_lab2","uri":"/hit_os_lab2/"},{"categories":["os"],"content":"4.总结 很多地方参考LOVE6的博客以及这个,对c语言不熟练，写函数实现磕磕碰碰的，但是对系统调用有了更深的认识。 ","date":"2024-04-15","objectID":"/hit_os_lab2/:0:4","tags":["lab"],"title":"Hit_os_lab2","uri":"/hit_os_lab2/"},{"categories":["os"],"content":"哈工大操作系统lab1","date":"2024-04-11","objectID":"/hit_os_lab1/","tags":["lab"],"title":"Hit_os_lab1","uri":"/hit_os_lab1/"},{"categories":["os"],"content":"hit os lab1 ","date":"2024-04-11","objectID":"/hit_os_lab1/:0:0","tags":["lab"],"title":"Hit_os_lab1","uri":"/hit_os_lab1/"},{"categories":["os"],"content":"1.实验内容 此次实验的基本内容是： 阅读《Linux 内核完全注释》的第 6 章，对计算机和 Linux 0.11 的引导过程进行初步的了解； 按照下面的要求改写 0.11 的引导程序 bootsect.s 有兴趣同学可以做做进入保护模式前的设置程序 setup.s。 改写 bootsect.s 主要完成如下功能： bootsect.s 能在屏幕上打印一段提示信息“XXX is booting…”，其中 XXX 是你给自己的操作系统起的名字，例如 LZJos、Sunix 等（可以上论坛上秀秀谁的 OS 名字最帅，也可以显示一个特色 logo，以表示自己操作系统的与众不同。） 改写 setup.s 主要完成如下功能： bootsect.s 能完成 setup.s 的载入，并跳转到 setup.s 开始地址执行。而 setup.s 向屏幕输出一行\"Now we are in SETUP\"。 setup.s 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。 setup.s 不再加载 Linux 内核，保持上述信息显示在屏幕上即可。 在实验报告中回答如下问题： 有时，继承传统意味着别手蹩脚。x86 计算机为了向下兼容，导致启动过程比较复杂。请找出 x86 计算机启动过程中，被硬件强制，软件必须遵守的两个“多此一举”的步骤（多找几个也无妨），说说它们为什么多此一举，并设计更简洁的替代方案。 ","date":"2024-04-11","objectID":"/hit_os_lab1/:0:1","tags":["lab"],"title":"Hit_os_lab1","uri":"/hit_os_lab1/"},{"categories":["os"],"content":"2.实验开始 1.改写bootsect.s 使用到int 0x10中断进行屏幕打印,出入参数： 寄存器 参数 AL 显示模式 BH 视频页 BL 属性值（如果AL=0x00或0x01 CX 字符串的长度 DH,DL 屏幕上显示起始位置的行、列值 ES:BP 字符串的段:偏移地址 在屏幕上打印的源码： ! Print some inane message mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#24 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#msg1 mov ax,#0x1301 ! write string, move cursor int 0x10 msg1: .byte 13,10 .ascii \"Loading system ...\" .byte 13,10,13,10 .org 508 root_dev: .word ROOT_DEV boot_flag: .word 0xAA55 我们将源码修改并只保留核心部分 entry _start _start: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#26 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#msg1 mov ax,#0x07c0 mov es,ax ! mov ax,#0x1301 ! write string, move cursor int 0x10 my_loop: jmp my_loop ! 死循环 msg1: .byte 13,10 .ascii \"LanceOS starting !!!\" .byte 13,10,13,10 .org 510 boot_flag: .word 0xAA55 我们相对于源码进行修改的部分： mov cx,#26 !这里是因为我们修改了msg1中的ascii码数量，修改为了26 mov ax,#0x07c0 ！因为源码在这之前已经修改了es的值，所以我们去除无关代码后也要给es赋值，es是字符串的段地址 mov es,ax ！ my_loop: jmp my_loop ! 死循环 msg1: .byte 13,10 .ascii \"LanceOS starting !!!\" ！修改为要修改的值 .byte 13,10,13,10 .org 510 ！这里是因为我们去除了无关的root_dev: .word ROOT_DEV,又要保证boot_flag: .word 0xAA55在引导磁盘最后两个字节，所以508修改为510 打印成功 2.改写setup.s 由于我们是重新开始写的bootsect.s，所以我们需要在新的bootsect.s中添加启动setup的代码 添加后的bootsect.s，成功加载setup SETUPLEN = 4 ! nr of setup-sectors SETUPSEG = 0x07e0 ! 因为我们在新的bootsect中并没有将代码移动到0x90000，所以依旧还是在0x07c0,在0x07c0基础上移动521字节，所以改成0x07e0 entry _start _start: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#26 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#msg1 mov ax,#0x07c0 mov es,ax mov ax,#0x1301 ! write string, move cursor int 0x10 load_setup: mov dx,#0x0000 ! drive 0, head 0 mov cx,#0x0002 ! sector 2, track 0 mov bx,#0x0200 ! address = 512, in INITSEG mov ax,#0x0200+SETUPLEN ! service 2, nr of sectors int 0x13 ! read it jnc ok_load_setup ! ok - continue mov dx,#0x0000 mov ax,#0x0000 ! reset the diskette int 0x13 j load_setup ok_load_setup: jmpi 0,SETUPSEG msg1: .byte 13,10 .ascii \"LanceOS starting !!!\" .byte 13,10,13,10 .org 510 boot_flag: .word 0xAA55 新的setup.s，成功打印\"Now we are in SETUP\" entry _start _start: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#25 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#msg2 mov ax,cs mov es,ax mov ax,#0x1301 ! write string, move cursor int 0x10 my_loop: jmp my_loop ! 死循环 msg2: .byte 13,10 .ascii \"Now we are in SETUP\" .byte 13,10,13,10 .org 510 boot_flag: .word 0xAA55 获取硬件参数，并打印到屏幕，这部分代码比较复杂，直接看实验给出的答案吧： INITSEG = 0x9000 entry _start _start: ! Print \"NOW we are in SETUP\" mov ah,#0x03 xor bh,bh int 0x10 mov cx,#25 mov bx,#0x0007 mov bp,#msg2 mov ax,cs mov es,ax mov ax,#0x1301 int 0x10 mov ax,cs mov es,ax ! init ss:sp mov ax,#INITSEG mov ss,ax mov sp,#0xFF00 ! Get Params mov ax,#INITSEG mov ds,ax mov ah,#0x03 xor bh,bh int 0x10 mov [0],dx mov ah,#0x88 int 0x15 mov [2],ax mov ax,#0x0000 mov ds,ax lds si,[4*0x41] mov ax,#INITSEG mov es,ax mov di,#0x0004 mov cx,#0x10 rep movsb ! Be Ready to Print mov ax,cs mov es,ax mov ax,#INITSEG mov ds,ax ! Cursor Position mov ah,#0x03 xor bh,bh int 0x10 mov cx,#18 mov bx,#0x0007 mov bp,#msg_cursor mov ax,#0x1301 int 0x10 mov dx,[0] call print_hex ! Memory Size mov ah,#0x03 xor bh,bh int 0x10 mov cx,#14 mov bx,#0x0007 mov bp,#msg_memory mov ax,#0x1301 int 0x10 mov dx,[2] call print_hex ! Add KB mov ah,#0x03 xor bh,bh int 0x10 mov cx,#2 mov bx,#0x0007 mov bp,#msg_kb mov ax,#0x1301 int 0x10 ! Cyles mov ah,#0x03 xor bh,bh int 0x10 mov cx,#7 mov bx,#0x0007 mov bp,#msg_cyles mov ax,#0x1301 int 0x10 mov dx,[4] call print_hex ! Heads mov ah,#0x03 xor bh,bh int 0x10 mov cx,#8 mov bx,#0x0007 mov bp,#msg_heads mov ax,#0x1301 int 0x10 mov dx,[6] call print_hex ! Secotrs mov ah,#0x03 xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 mov bp,#msg_sectors mov ax,#0x1301 int 0x10 mov dx,[12] call print_hex inf_loop: jmp inf_loop print_hex: mov cx,#4 print_digit: rol dx,#4 mov ax,#0xe0f and al,dl add al,#0x30 cmp al,#0x3a jl outp add al,#0x07 outp: int 0x10 loop print_digit ret print_nl: mov ax,#0xe0d ! CR","date":"2024-04-11","objectID":"/hit_os_lab1/:0:2","tags":["lab"],"title":"Hit_os_lab1","uri":"/hit_os_lab1/"},{"categories":["工具"],"content":"对vim的部分较常用按键进行小总结","date":"2024-03-26","objectID":"/vim%E9%83%A8%E5%88%86%E5%B8%B8%E7%94%A8%E6%8C%89%E9%94%AE/","tags":["工具"],"title":"Vim部分常用按键","uri":"/vim%E9%83%A8%E5%88%86%E5%B8%B8%E7%94%A8%E6%8C%89%E9%94%AE/"},{"categories":["工具"],"content":"vim 部分常用按键总结 移动 上：k 下：j 左：h 右：l 向后移动一个单词：w 向前移动一个单词：b 跳转文件最后一行：G 跳转文件第一行：gg 显示光标所在行和文件状态信息：ctrl+G 跳转指定行号：行号+G 跳转到行尾：$ 跳转到行首：^ 屏幕底行：L 屏幕顶行：H 屏幕中间行：M 插入 当前位置插入：i 当前位置后面一个位置插入：a 当前行尾插入：A 在当前位置下一行插入：o 在当前位置上一行插入：O 删除 删除：x 删除单词：dw 删除当前位置到末尾：d$ 删除整行：dd 撤销 撤销最后执行的命令：u 撤销整行的修改：U 撤销撤销命令：ctrl+r 复制粘贴 将最后删除的内容置入光标之后(粘贴)：p 复制：y 替换 替换字符：r+要替换成的字符 从当前位置开始一直替换(替换模式)：R 改变单词从当前位置到单词尾,同时也进入插入模式：ce+要替换的单词 改变从当前位置到行尾：c$ 查找 查找字符串：/ 目标字符串(? 与/ 查找方向相反) 查找上一次字符串：n 查找上一次字符串(反向)：N 配对括号查找：% 替换 替换一个匹配：s/old/new/ 将old替换为new 替换全行：s/old/new/g 命令 执行外部命令：:! 保存为指定文件名：:w 文件名 提取合并文件：:r 文件名 计数操作：2w(向前移动2个单词)，3e(向前移动到3个单词末尾) d2w(删除两个单词) 可视 可视模式：v (可选择截取文本) ","date":"2024-03-26","objectID":"/vim%E9%83%A8%E5%88%86%E5%B8%B8%E7%94%A8%E6%8C%89%E9%94%AE/:0:0","tags":["工具"],"title":"Vim部分常用按键","uri":"/vim%E9%83%A8%E5%88%86%E5%B8%B8%E7%94%A8%E6%8C%89%E9%94%AE/"},{"categories":["云原生"],"content":"容器网络","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%94%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/","tags":["container"],"title":"从0到1写docker之五容器网络","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%94%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/"},{"categories":["云原生"],"content":"(五)容器网络 (容器网络理解不深，待我计网大成之日，再重新写这篇容器网络的博客) linux网络虚拟网络设备 veth：成对出现的虚拟网络设备，发送到veth一端的请求会从另一端发出，实现点对点的连接 +------------------+ +------------------+ | ns1 | | ns2 | | | veth pair | | | +-+ +-+ | | 192.168.1.1/24 | +--------------+ | 192.168.1.2/24 | | (veth-ns1) +-+ +-+ (veth-ns2) | | | | | | | | | | | | | +------------------+ +------------------+ bridge：用来桥接的网络设备，相当于现实世界的交换机，可以连接不同的网络设备，请求到达bridge设备时，可以通过报文中Mac地址进行广播或群发。 +------------------+ +------------------+ +------------------+ | | | | | | | | | | | | | | | | | | | ns1 | | ns2 | | ns3 | | | | | | | | | | | | | | | | | | | | 192.168.1.1/24 | | 192.168.1.2/24 | | 192.168.1.3/24 | +----(veth-ns1)----+ +----(veth-ns2)----+ +----(veth-ns3)----+ + + + | | | | | | + + + +--(veth-ns1-br)-------------(veth-ns2-br)------------(veth-ns3-br)--+ | | | linux-bridge | | | +--------------------------------------------------------------------+ linux路由表 如果两个namespace处于不同的两个子网中，那么就不能通过bredge进行连接了，需用路由器三层转发，但是linux并未提供虚拟路由器设备，linux本身就具有路由器功能， linux iptables iptables用来管理包的流动和转送,用于容器和宿主机外部的网络通信 MASQUERADE:将namespace中的源地址转换为宿主机中的地址，就可以访问宿主机外的网络了 DNAT:将宿主机上端口的tcp请求转发到namespace中的地址，实现外部的应用调用 另外的两个组件： 网络驱动：网络的管理 IPAM：分配ip 具体实现请看我的项目代码… ","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%94%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/:0:0","tags":["container"],"title":"从0到1写docker之五容器网络","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%94%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/"},{"categories":["云原生"],"content":"参考文档 《自己动手写docker》 https://www.zhaohuabing.com/post/2020-03-12-linux-network-virtualization/ ","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%94%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/:0:1","tags":["container"],"title":"从0到1写docker之五容器网络","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%94%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/"},{"categories":["云原生"],"content":"构建复杂容器，支持了-d,ps,logs,exec,stop,rm,-e,并优化了overlayFS的结构","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E5%9B%9B%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E5%AE%B9%E5%99%A8/","tags":["container"],"title":"从0到1写docker之四构建复杂容器","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E5%9B%9B%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E5%AE%B9%E5%99%A8/"},{"categories":["云原生"],"content":"(四)构建复杂容器 1.容器后台运行 增加detach标签，并不允许创建tty和detach同时存在 if tty \u0026\u0026 detach{ log.Println(\"the tty and detach can't exist at the same time\") return } 并且在Run命令中更改： if tty { cmd.Wait() //父进程等待子进程 } 因为cmd.Wait()是让父进程等待子进程，如果我们要实现让容器后台运行，那么就不需要父进程等待子进程，子进程此时就会被init进程控制 2.保存容器信息 在创建容器的同时，将容器信息写入到宿主机的文件中，我们保存到/var/run/gocker目录中 type ContainerInfo struct { Pid string `json:\"pid\"` ContainerName string `json:\"container_name\"` ContainerId string ` json:\"container_id\"` CreateAtTime string `json:\"create_at_time\"` Command string `json:\"command\"` Status string `json:\"status\"` } var ( RUNING = \"runing\" STOP = \"stopped\" EXIT = \"exited\" DefaultInfoLocation = \"/var/run/gocker/%s/\" ConfigName = \"config.json\" ) func RecordContainerInformation(containerName string, containerPid int, command []string) (string, error) { id := randStringBytes(10) createTime := time.Now().Format(\"2006-01-02 15:04:05\") if containerName == \"\" { containerName = id } cmd := strings.Join(command, \" \") info := \u0026ContainerInfo{ Pid: strconv.Itoa(containerPid), ContainerName: containerName, ContainerId: id, CreateAtTime: createTime, Status: RUNING, Command: cmd, } infoByte, err := json.Marshal(info) if err != nil { log.Println(\"can't marshal the information\") return \"\", err } location := fmt.Sprintf(DefaultInfoLocation, containerName) log.Println(\"the location is \", location) _, err = os.Stat(location) if err != nil \u0026\u0026 !os.IsNotExist(err) { log.Println(\"the status of the config file can't judge\") return \"\", err } if os.IsNotExist(err) { if err := os.MkdirAll(location, 0755); err != nil { return \"\", err } } file, err := os.Create(path.Join(location, ConfigName)) if err != nil { log.Println(\"can't create the config file\") return \"\", err } defer file.Close() _, err = file.Write(infoByte) if err != nil { log.Println(\"can't write the byte of information into the target file\") return \"\", err } log.Println(\"record the informaiton successful!\") return containerName, nil } func randStringBytes(n int) string { num := \"01234567890123456789\" by := make([]byte, n) r := rand.New(rand.NewSource(time.Now().Unix())) for i, _ := range by { by[i] = num[r.Intn(n)] } return string(by) } func DeleteContainerInfo(containerName string){ location := fmt.Sprintf(DefaultInfoLocation,containerName) dirPath := location+ConfigName if err := os.RemoveAll(dirPath);err != nil{ log.Println(\"can't delete the config file\") } } 3.实现ps命令 ps命令就是去前面保存容器信息的目录中遍历所有的文件，拿到所有的信息 func ListContainers() { dir := fmt.Sprintf(DefaultInfoLocation, \"\") dir = dir[:len(dir)-1] files, err := os.ReadDir(dir) if err != nil { log.Println(\"can't read the all directory\") return } var containers []*ContainerInfo for _, file := range files { info, _ := file.Info() data, err := readInfoFromFile(info) if err != nil { log.Println(\"read container information failed\") continue } containers = append(containers, data) } w:=tabwriter.NewWriter(os.Stdout,12,1,3,' ',0) fmt.Fprintf(w,\"Container_Id\\tContainer_Name\\tPid\\tStatus\\tCommand\\tCreate_At_Time\\n\") for _,con := range containers { fmt.Fprintf(w,\"%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t\\n\",con.ContainerId,con.ContainerName,con.Pid,con.Status,con.Command,con.CreateAtTime, ) } if err := w.Flush();err != nil{ log.Println(\"can't flush to stdout\") return } } func readInfoFromFile(file os.FileInfo) (*ContainerInfo, error) { containerName := file.Name() dir := fmt.Sprintf(DefaultInfoLocation, containerName) dir = dir + ConfigName info, err := os.ReadFile(dir) if err != nil { log.Println(\"can't read the file\") return nil, err } var data = \u0026ContainerInfo{} err = json.Unmarshal(info, data) if err != nil { log.Println(\"can't unmarshal the information \") return nil, err } return data, nil } 4.实现logs命令 当使用了-d标签，此时的后台运行的容器，我们是无法知道运行情况的，所以就需要logs来记录下后台运行容器的标准输出 需要先将detach容器的标准输出流定向到log文件中，在创建父进程的函数newparentProcess中： if tty { cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr } else { dir := fmt.Sprintf(DefaultInfoLocation,containerName) if err := os.MkdirAll(dir,0622);err!= nil{ log.Println(\"can't make all directory\")","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E5%9B%9B%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E5%AE%B9%E5%99%A8/:0:0","tags":["container"],"title":"从0到1写docker之四构建复杂容器","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E5%9B%9B%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E5%AE%B9%E5%99%A8/"},{"categories":["云原生"],"content":"构建简易镜像，并使用overlayFS包装镜像，数据卷挂载，支持简单容器打包","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%B8%89%E6%9E%84%E5%BB%BA%E7%AE%80%E6%98%93%E9%95%9C%E5%83%8F/","tags":["container"],"title":"从0到1写docker之三构建简易镜像","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%B8%89%E6%9E%84%E5%BB%BA%E7%AE%80%E6%98%93%E9%95%9C%E5%83%8F/"},{"categories":["云原生"],"content":"(三)构建简易镜像: 补充知识： rootfs(root filesystem): rootfs是分层文件树的顶端，包含对系统运行至关重要的文件和目录，包括设备目录和用于启动系统的程序。系统启动时，初始化进程会将rootfs挂载到/目录，之后再挂载其他文件系统到其子目录。 mount namespace 工作原理： 每个进程可以创建属于自己的 mount table，但前提是必须先复制父进程的 mount table，之后再调用 mount 发生的更改都只会影响当前进程的 mount table pivot_root系统调用介绍： pivot_root 是由 Linux 提供的一种系统调用，它能够将一个 mount namespace 中的所有进程的根目录和当前工作目录切换到一个新的目录。pivot_root 的主要用途是在系统启动时，先挂载一个临时的 rootfs 完成特定功能，然后再切换到真正的 rootfs。 可以将当前root文件系统移动到put_old文件夹中，然后将new_root成为新的root文件系统(注：new_root和put_old不能同时存在当前root的同一个文件系统中) pivot_root与chroot区别： chroot只改变某个进程的根目录，系统的其他部分依旧运行于旧的root目录。 pivot_root把整个系统切换到一个新的root目录中，然后去掉对之前rootfs的依赖，以便于可以umount之前的文件系统。 1.使用busybox来构建极简镜像 项目中使用privot_root系统调用的函数： // pivotRoot 进行pivot_root系统调用 func pivotRoot(root string )error{ //为了使当前root文件系统的老root文件系统和新root文件系统不在同一个文件系统下，这里把root重新mount一次 //bind mount 就是把相同的内容换一个挂载点的挂载方式 err := syscall.Mount(root,root,\"bind\",syscall.MS_BIND |syscall.MS_REC,\"\") if err != nil{ return errors.New(\"Mount rootfs to itself failed,error:\"+err.Error()) } //存储旧root文件系统 pivotDir := filepath.Join(root,\".pivot_root\") err = os.Mkdir(pivotDir,0777) if err != nil{ return err } //root 为新root文件系统，pivotDir代表put_old文件夹，将旧root文件系统放在pivotDir文件夹中 err = syscall.PivotRoot(root,pivotDir) if err != nil { return errors.New(\"pivot_root,error :\"+err.Error()) } err = syscall.Chdir(\"/\") if err != nil{ return errors.New(\"chdir,error:\"+err.Error()) } //此时的pivotDir就是刚刚存放旧的root文件系统的文件夹 pivotDir = filepath.Join(\"/\",\".pivot_root\") err = syscall.Unmount(pivotDir,syscall.MNT_DETACH) if err != nil{ return errors.New(\"umount pivot_roo5t directory failed ,error :\"+err.Error()) } return os.Remove(pivotDir) } 再将原先在InitProcess函数中进行mount操作移到setUpMount函数中，同时进行pivot_root： func setUpMount(){ pwd ,err := os.Getwd() if err != nil{ log.Println(\"get current location error:\"+err.Error()) return } log.Println(\"the current location is \"+pwd) err = syscall.Mount(\"\",\"/\",\"\",syscall.MS_REC | syscall.MS_PRIVATE,\"\") if err != nil{ log.Println(\"the first mount failed,error:\",err.Error()) } err = pivotRoot(pwd) if err != nil{ log.Println(\"pivot_root system call failed\") } //mount proc defaultMountFlag := syscall.MS_NODEV | syscall.MS_NOSUID | syscall.MS_NOEXEC // 这里的 MountFlag 的意思如下。 // 1. MS_NOEXEC在本文件系统中不允许运行其他程序。 // 2. MS_NOSUID在本系统中运行程序的时候， 不允许 set-user-ID或 set-group-ID。 // 3. MS_NODEV这个参数是自从Linux2.4以来，所有mount的系统都会默认设定的参数。 syscall.Mount(\"proc\",\"/proc\",\"proc\",uintptr(defaultMountFlag),\"\") //mount tmpfs syscall.Mount(\"tmpfs\",\"/dev\",\"tmpfs\",syscall.MS_NOSUID | syscall.MS_STRICTATIME,\"mode=755\") } 这里挂载到/，可以使后面挂载的/proc在退出容器时自动umount /proc,因为这样可以声明这个新的mount namespace独立 (注!!!:这个/挂载，必须要在所有挂载之前) 现在InitProcess函数就是这个样子： func InitProcess() error { data := readUserCommand() if len(data) ==0 { return errors.New(\"Run container get command failed\") } setUpMount() //将mount封装 log.Println(\"mount success\") //通过exec.LookPath找到命令在环境变量中路径 cmdpath, err := exec.LookPath(data[0]) if err != nil { log.Println(data[0],\" look path in PATH environment variable failed\") return err } err = syscall.Exec(cmdpath, data[0:], os.Environ()) //!!!最重要的操作 //syscall.Exec这个方法, //其实最终调用了Kernel的intexecve(const char *filename,char *const argv[], char *const envp[]); //这个系统函数。它的作用是执行当前 filename对应的程序。 //它会覆盖当前进程的镜像、数据和堆栈等信息，包括 PID， 这些都会被将要运行的进程覆盖掉。 //保证了我们进入容器之后，我们看到的第一个进程是我们指定的进程，因为之前的信息都被覆盖掉了 if err != nil { log.Fatal(\"error :\", err.Error()) } log.Println(\"exec success\") return nil } 完成后的结果就是这样： / # ps PID USER TIME COMMAND 1 root 0:00 sh 7 root 0:00 ps / # mount /dev/sdc on / type ext4 (rw,relatime,discard,errors=remount-ro,data=ordered) proc on /proc type proc (rw,nosuid,nodev,noexec,relatime) tmpfs on /dev type tmpfs (rw,nosuid,mode=755) / # ls bin dev etc home proc root sys tmp usr var 此时子进程就看不到父进程的mount信息，且rootfs切换成了我们设置的busybox 2.使用union filesystem来包装镜像 这里选择使用overlayFS，作为unionfs 相较于aufs，overlayFS的优势： 速度更快，aufs层数更多，性能损耗更大 简单，overlay2只有两层，容器层upper和镜像层lower overlay2加入了linux kernel 相较于overlay驱动，overlay2驱动的优势： overlay驱动只在一个lower overlayFS层之上，所以为了实现多层镜像需要大量的硬链接 overlay2驱动原生支持多个lower overlayFS","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%B8%89%E6%9E%84%E5%BB%BA%E7%AE%80%E6%98%93%E9%95%9C%E5%83%8F/:0:0","tags":["container"],"title":"从0到1写docker之三构建简易镜像","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%B8%89%E6%9E%84%E5%BB%BA%E7%AE%80%E6%98%93%E9%95%9C%E5%83%8F/"},{"categories":["云原生"],"content":"构建简易容器，实现namespace和cgroup","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%8C%E6%9E%84%E5%BB%BA%E7%AE%80%E6%98%93%E5%AE%B9%E5%99%A8/","tags":["container"],"title":"从0到1写docker之二构建简易容器","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%8C%E6%9E%84%E5%BB%BA%E7%AE%80%E6%98%93%E5%AE%B9%E5%99%A8/"},{"categories":["云原生"],"content":"(二)创建简易容器 ","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%8C%E6%9E%84%E5%BB%BA%E7%AE%80%E6%98%93%E5%AE%B9%E5%99%A8/:0:0","tags":["container"],"title":"从0到1写docker之二构建简易容器","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%8C%E6%9E%84%E5%BB%BA%E7%AE%80%E6%98%93%E5%AE%B9%E5%99%A8/"},{"categories":["云原生"],"content":"实现namespace和cgroup 通过实现一个简易的run命令，来构建容器 run命令的实现流程： 通过newparentProcess函数，构建一个父进程，此时已经进行了namespace 使用cgroup来对资源的限制，此时容器就已经创建完毕 创建init子进程(容器内第一个进程)，mount到/proc文件系统(方便ps命令)，同时使用syscall.Exec来覆盖之前的进程信息，堆栈信息(保证第一个进程是我们规定的进程)。 在容器中简单实现namespace和cgroup： namespace的实现之间进行系统调用： cmd.SysProcAttr = \u0026syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWNS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNET | syscall.CLONE_NEWUTS, //syscall.CLONE_NEWUSER, } 我们这里暂时不实现user namespace，因为较复杂会牵涉到权限等问题 cgroup则是通过读取/proc/self/mountinfo文件，获取当前进程的mount 情况，再根据我们需要限制的subsystem来获取到cgroup的挂载点，例如：/sys/fs/cgroup/memory，此时的subsystem为memory。 (本项目中仅支持了memory,cpuset ,cpushare进行了资源限制，本质上都是对文件进行读写操作) // FindCgroupMountPoint 获取cgroup挂载点 func FindCgroupMountPoint(subsystem string) string { file, err := os.Open(\"/proc/self/mountinfo\") if err != nil { log.Println(\"can't open /proc/self/mountinfo\") return \"error :can't open file\" } defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { txt := scanner.Text() fileds := strings.Split(txt, \" \") for _, opt := range strings.Split(fileds[len(fileds)-1], \",\") { if opt == subsystem { log.Println(\"the mount point : \",fileds[4]) return fileds[4] } } } if err := scanner.Err(); err != nil { return \"\" } return \"\" } // GetCgroupAbsolutePath 获取cgroup绝对路径 // 找到对应subsystem挂载的 hierarchy 相对路径对应的 cgroup 在虚拟文件系统中的路径, // 然后通过这个目录的读写去操作 cgroup // Cgroups 的 hierarchy 的虚拟文件系统是通过 cgroup类型文件系统的 mount挂载上去的, // option 中加上 subsystem，代表挂载的 subsystem 类型 , // 这样就可以在 mountinfo 中找到对应的 subsystem 的挂载目录了，比如 memory。 func GetCgroupAbsolutePath(subsys string, cgroupPath string, autoCreate bool) (string, error) { cgroupRoot := FindCgroupMountPoint(subsys) if _, err := os.Stat(path.Join(cgroupRoot, cgroupPath)); err == nil || (autoCreate \u0026\u0026 os.IsNotExist(err)) { if os.IsNotExist(err) { err := os.Mkdir(path.Join(cgroupRoot, cgroupPath), 0755) if err != nil { return \"\", errors.New(\"cgroup path error :\" + err.Error()) } return path.Join(cgroupRoot, cgroupPath), nil } return path.Join(cgroupRoot, cgroupPath), nil } else { return \"\", errors.New(\"cgroup path error :\" + err.Error()) } } 找到了cgroup挂载的绝对路径，就可以通过操作文件来进行资源限制,这里以memory为例： 通过set方法，将设置的内存资源限制写入memory.limit_in_bytes文件中； 通过apply方法，把pid写入到tasks，目标进程加入到该cgroup中(！！！这里必须要注意，如果你在set中写入的数据格式不争取，是无法将pid写入tasks的)； 通过remove方法，则是取消该cgroup // 设置对应的cgroup memory限制 func (m *MemorySubsystem) Set(cgroupPath string, resource *ResouceConfig) error { //获取subsystem路径(cgroup绝对路径) absolutePath, err := GetCgroupAbsolutePath(m.Name(), cgroupPath, true) if err != nil { return err } //设置内存限制 if resource.MemoryLimit != \"\"{ err = os.WriteFile(path.Join(absolutePath, \"memory.limit_in_bytes\"), []byte(resource.MemoryLimit), 0644) if err != nil { return errors.New(\"set memory failed,error:\" + err.Error()) } } return nil } func (m *MemorySubsystem) Apply(cgroupPath string, pid int) error { absolutePath,err := GetCgroupAbsolutePath(m.Name(),cgroupPath,false) if err != nil{ return errors.New(\"apply cgroup faield ,error:\"+err.Error()) } err = os.WriteFile(path.Join(absolutePath, \"tasks\"), []byte(strconv.Itoa(pid)), 0644) if err != nil { return errors.New(\"apply cgroup faield ,error:\" + err.Error()) } return nil } func (m *MemorySubsystem) Remove(cgroupPath string) error { absolutePath ,err := GetCgroupAbsolutePath(m.Name(),cgroupPath,false) if err != nil{ return err } err = os.Remove(absolutePath) if err != nil{ return err } return nil } ","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%8C%E6%9E%84%E5%BB%BA%E7%AE%80%E6%98%93%E5%AE%B9%E5%99%A8/:0:1","tags":["container"],"title":"从0到1写docker之二构建简易容器","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%8C%E6%9E%84%E5%BB%BA%E7%AE%80%E6%98%93%E5%AE%B9%E5%99%A8/"},{"categories":["云原生"],"content":"参考文档 《自己动手写docker》 https://tech.meituan.com/2015/03/31/cgroups.html https://www.cnblogs.com/charlieroro/p/10281469.html https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/resource_management_guide/index ","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%8C%E6%9E%84%E5%BB%BA%E7%AE%80%E6%98%93%E5%AE%B9%E5%99%A8/:1:0","tags":["container"],"title":"从0到1写docker之二构建简易容器","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%BA%8C%E6%9E%84%E5%BB%BA%E7%AE%80%E6%98%93%E5%AE%B9%E5%99%A8/"},{"categories":["云原生"],"content":"理解docker的三大底座概念","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%B8%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/","tags":["container"],"title":"从0到1写docker之一概念理解","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%B8%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"},{"categories":["云原生"],"content":"(一)概念理解 项目地址 欢迎folk，star，follow🥰，有问题欢迎提issue，pr ","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%B8%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/:0:0","tags":["container"],"title":"从0到1写docker之一概念理解","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%B8%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"},{"categories":["云原生"],"content":"docker 三大核心技术： Namespace: UTS Namespace 主要用来隔离 nodename 和 domainname 两个系统标识 IPC Namespace 用来隔离 System V IPC 和 POSIX message queues(进程间通信) PID Namespace是用来隔离进程 ID的 MountNamespace用来隔离各个进程看到的挂载点视图 User Namespace 主要是隔离用户的用户组 ID Network Namespace 是用来隔离网络设备、 IP地址端口 等网络械的 Namespace。 Cgroups: 四个重要的概念：tasks，cgroup，hierarchy，subsystem tasks:就是一个进程 cgroup:控制族群，也就是一个按某种规定划分的进程组，cgroups使用的资源都是以控制族群为单位划分的 hierarchy:层级，是由多个cgroup组成的树状关系， subsystem:资源子系统，相当于资源控制器，如cpu，memory子系统，必须附加到某个层级hierarchy才能起作用， union file system: 把其他文件系统联合到一个联合挂载点的文件系统服务，具有写时复制和联合挂载的特性 现在docker多采用的是overlayFS，包含四个部分，upper，lower，work，merged ","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%B8%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/:1:0","tags":["container"],"title":"从0到1写docker之一概念理解","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%B8%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"},{"categories":["云原生"],"content":"参考文档： 《自己动手写docker》 https://blog.csdn.net/qq_31960623/article/details/120260769 https://www.cnblogs.com/crazymakercircle/p/15400946.html#autoid-h3-2-2-0 ","date":"2024-02-24","objectID":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%B8%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/:2:0","tags":["container"],"title":"从0到1写docker之一概念理解","uri":"/%E4%BB%8E0%E5%88%B01%E5%86%99docker%E4%B9%8B%E4%B8%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"},{"categories":["杂事"],"content":"我的2023年度总结","date":"2024-01-02","objectID":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","tags":["杂事"],"title":"2023年度总结","uri":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["杂事"],"content":"2023年度总结🥳 ","date":"2024-01-02","objectID":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:0","tags":["杂事"],"title":"2023年度总结","uri":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["杂事"],"content":"前言 看到很多学长都在写年度总结，那我也跟个风吧，记录一下过去一年的收获和感悟吧。马上就是期末周，太多东西要学，后面应该没多少时间，索性就现在写了。 ","date":"2024-01-02","objectID":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:1","tags":["杂事"],"title":"2023年度总结","uri":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["杂事"],"content":"经历 高考 现在回想起来好像教室，食堂，寝室三点一线，也没有什么能回想的起来了。 高考发挥正常，来了重邮🥹，对自己的实力还是有预期，也没什么大不了了。 暑假 18年以来，可以说今年的暑假是最充实的一个暑假了😎。 回想起往年的暑假都是天天打游戏，打得昏天黑地。今年的暑假还是学到了很多东西。 刚考完高考，志愿填报全填的计算机专业，就准备进军互联网~~（不知道找工作时的自己会不会怪自己,互联网寒冬了）~~，开始网上找编程的教程学习，当时不知道要学什么编程语言，看网上推荐就开始学习python了。当时就看好了重邮，志愿一半都是重邮，就阴差阳错加了重邮的贴吧群，到处问学长学姐。 群里有一个学姐主动加了我（人很好，但是是卖卡的），当时聊了很多，在她那里了解到了软工会学C++，于是我就放弃了学习python，转投C++。也在她那里正式了解到了红岩，蓝山，勤奋蜂等工作室，当时就对这些工作室产生了兴趣。 在贴吧群也认识到了一个红岩的学长（红岩安卓的，现在是腾讯✌️😭），和他沟通之后，他直接建议我学go，docker，linux基础，mysql等等，给当时懵懂的我带来不小的震撼🫨。 之后又了解到了一个同专业同级的大佬，此时我还在学C++的指针，他就已经会了python，C++，go，rust，更不用说数据库和docker那些了。本以为暑假学点C++，能开学薄纱同学，看来还是想多了🤡，哈哈哈哈。 Q:暑假收获到了什么呢？ A:一点点C++语法（至少学校的程序化结构设计的进度还没我快，虽然还讲了一些底层原理啥的，但还是觉得上课耽误学习），go的语法，和部分基础linux命令。另外还有一个驾驶证🪪。 新学期 加入了红岩和蓝山作为学员进一步学习，也了解到了两边的牛逼的学长（比如袁神，王鑫学长，紫雨哥，旭哥等等，此处省略一千字），红岩感觉压力有点大，毕竟要刷人，蓝山压力不是很大，而且还有大工位（对于挤在皇家里面生存的我来说太有诱惑力了）。 根据暑假了解到的一些信息，我坚定地选择了毕业工作的道路，毕竟我也不想浪费两三年的时间去读研，最后本硕同薪的结果（要是一直都是现在这个互联网行情，说不定还找不到工作😭）。 刚开学跟现在期末比起来变化确实很大，更多的是我的心态上，不得不说大学确实很容易让人堕落： 刚开学那会确实学的很快，军训期间一直在看计算机网络，虽然没学多少。然后军训结束国庆放假，一个人守舍，把mysql系统刷了一遍，把表锁行锁啥的学了，就没学了，好像还有读写分离（但是现在就基本只用到简单的crud😅，其他的忘的差不多了）。然后跟着蓝山去年开源出来的课件，把redis和docker浅浅地过了一遍（因为浅，所以后面又学了一遍）。 刚开始我对游戏根本不感兴趣，但是逐渐跟着室友一起打游戏，喜欢上了玩cs2。然后就花了很多时间来跟室友打游戏了，慢慢地也没有之前那么卷了，所以说寝室真的不适合学习。 其他的也没啥好说的了… ","date":"2024-01-02","objectID":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:2","tags":["杂事"],"title":"2023年度总结","uri":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["杂事"],"content":"2024上半年的目标 1.把业务的菜名能学的都学了(这个就比较长远了) 2.最近在尝试复刻一个docker🐳，尽量在寒假之前完成吧 3.坚持在工作室的学习，加入一个工作室 4.学习计算机基础四大件(最近在学习数据结构，争取快点学完吧) 5.坚持每天都刷点leetcode(前提是先学完数据结构与算法) 6.学习C++ 7.学习Rust🦀(最近是没时间学咯) 8.找个女朋友🫣 9.work \u0026\u0026 life balance🥹 to be continue…","date":"2024-01-02","objectID":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:3","tags":["杂事"],"title":"2023年度总结","uri":"/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["数据结构与算法"],"content":"学习笔记","date":"2023-12-24","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(二)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/"},{"categories":["数据结构与算法"],"content":"数据结构与算法入门(二) ","date":"2023-12-24","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/:0:0","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(二)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/"},{"categories":["数据结构与算法"],"content":"第三章（续） 静态链表（游标实现法）： 让数组的元素都是由两个数据域组成，data和cur。也就是 说，数组的每个下标都对应一个data和一个cur。数据域data，用来存 放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的 next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标。 #define MAXSIZE 1000 typedef struct { ElemType data; int cur;//游标Cursor,为0表示无指向 }Component, StaticLinkList[MAXSIZE]; //对于不提供结构struct的程序设计语言，可以使用一对并行数据data和cur来处理 初始化静态链表： //初始化数组状态 Status InitList(StaticLinkList space){ int i ; for (i = 0 ; i \u003cMAXSIZE-1;i++){ space[i].cur = i +1; } space[MAXSIZE -1 ].cur = 0;//最后一个元素的cur存放第一个有数值的元素的下标，相当于单链表中的头结点作用 return OK; } 静态链表的插入操作： 为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过 的及已被删除的分量用游标链成一个备用的链表，每当进行插入时， 便可以从备用链表上取得第一个结点作为待插入的新结点。 int Malloc_SLL(StaticLinkList space ){ //返回第一个备用空闲的下标 int i = space[0].cur; if (space[0].cur){ //因为把第一个空闲的下标返回，所以需要把下一个分量拿来备用 space[0].cur = space[i].cur; } return i; } 具体实现： //在第i个元素前插入新的数据元素e Status ListInsert(StaticLinkList L , int i ,ElemType e){ int j , k , l; //k是最后一个元素的下标 k = MAXSIZE -1; if (i\u003c1 || i \u003e ListLength(L)+1){ return ERROR; } j = Malloc_SLL(L);//返回空闲分量的游标 if (j ){ L[j].data = e; //循环找到第i个元素之前的位置 for ( l = 1; l \u003ci -1 ; l++){ k = L[k].cur;//k = 第i-1个元素的游标 } L[j].cur = L[k].cur;//让插入元素的cur指向第i个元素 L[k].cur = j;//让第i-1个元素的cur指向新元素 return OK; } return ERROR; } 静态链表的删除操作： Status ListDelete(StaticLinkList L, int i ){ int j , k ; if (i \u003c1 || i \u003eListLength(L)){ return ERROR; } k = MAXSIZE -1; for (j = 1;j\u003c=i -1;j++){ k = L[k].cur; } j = L[k].cur; L[k].cur = L[j].cur; Free_SSL(L,j); return OK; } //将下标为k的空闲结点回收到备用链表 Status Free_SSL(StaticLinkList space,int k ){ //把备用链表的第一个元素的cur值赋给要删除的分量的cur space[k].cur =space[0].cur; //要删除的分量下标赋值给备用链表的第一个元素的cur space[0].cur = k; } 获取静态链表的元素个数： //返回静态链表的数据元素的个数 int ListLength(StaticLinkList L){ int j =0 ; int i = L[MAXSIZE -1 ].cur; while(i){ i = L[i].cur; j++; } return j; } 循环链表： 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单 链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。 （不用头指针，而是使用指向终端结点的尾指针） 合并两个循环链表的操作： /* 保存A表的头结点，即① */ p = rearA-\u003enext; /*将本是指向B表的第一个结点（不是头结点） */ rearA-\u003enext = rearB-\u003enext-\u003enext; /* 赋值给reaA-\u003enext，即② */ q = rearB-\u003enext; /* 将原A表的头结点赋值给rearB-\u003enext，即③ */ rearB-\u003enext = p; /* 释放q */ free(q); 双向链表： 双向链表（double linkedlist）：是在单向链表的每个结点中，再设置以一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针 域，一个指向直接后继，另一个指向直接前驱。 代码实现： typedef struct DulNode{ ElemType data; struct DulNode *prior;//直接前驱指针 struct DulNode *next ;//直接后续指针 }DulNode,*DuLinkList; ","date":"2023-12-24","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/:0:1","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(二)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/"},{"categories":["数据结构与算法"],"content":"第四章 栈与队列 4.2.1栈的定义： 栈(stack)是限定仅在表尾进行插入和删除操作的线性表 我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底 (bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出 (LastIn First Out)的线性表，简称LIFO结构。 栈的插入操作：也叫进栈，压栈，入栈（push） 栈的删除操作：也叫出栈，弹栈（pop） 4.3栈的抽象数据类型 ADT 栈(stack) Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。 Operation InitStack(*S): //初始化操作，建立一个空栈S。 DestroyStack(*S): // 若栈存在，则销毁它。 ClearStack(*S): //将栈清空。 StackEmpty(S): // 若栈为空，返回true，否则返回false。 GetTop(S, *e): //若栈存在且非空，用e返回S的栈顶元素。 Push(*S, e): //若栈S存在，插入新元素e到栈S中并成为栈顶元素。 Pop(*S, *e): // 删除栈S中栈顶元素，并用e返回其值。 StackLength(S): // 返回栈S的元素个数。 endADT 4.4栈的顺序存储结构及其实现 结构定义： //SElemType 视实际情况而定，这里假设为int typedef int SElemType ; const int MAXSIZE = 5; typedef struct { SElemType data[MAXSIZE]; int top;//表示栈顶指针 }SqStack; 进栈操作(push): //push Status Push (SqStack *S , SElemType e ) { //栈满 if (S-\u003etop ==MAXSIZE-1){ return ERROR; } //栈顶指针加一 S-\u003etop ++; //将新插入的元素赋值到栈顶 S-\u003edata[S-\u003etop]=e; return OK; } 出栈操作(pop): //pop //若栈不空，则删除S的栈顶元素，用e返回其值， 并返回OK;否则返回ERROR Status Pop(SqStack *S,SElemType e) { //空栈 if (S -\u003etop ==-1){ return ERROR; } e=S-\u003edata[S-\u003etop]; S-\u003etop--; return OK; } 4.5两栈共享空间 结构： //两栈共享空间 typedef struct { SElemType data[MAXSIZE]; int top1; //栈一栈顶指针 int top2; //栈二栈顶指针 }SqDoubleStack; 插入操作： Status Push(SqDoubleStack *S,SElemType e,int StackNumber) { //栈满了 if (S-\u003etop1 +1 == S-\u003etop2) { return ERROR; } if (StackNumber == 1) S-\u003edata[++S-\u003etop1]=e; else if (StackNumber ==2) S-\u003edata[--S-\u003etop2]=e; return OK; } 删除操作： //如果栈不为空，就用e返回删除的值，并且返回ok，失败则返回error Status Pop(SqDoubleStack *S,SElemType *e,int StackNumber ) { if (StackNumber == 1){ if (S-\u003etop1 ==-1) { //说明栈一为空 return ERROR; } *e = S-\u003edata[S-\u003etop1--]; } else if (StackNumber ==2){ if (S-\u003etop2 ==-1) { //说明栈二为空 return ERROR; } *e = S-\u003edata[S-\u003etop2++]; } return OK; } 4.6 栈的链式存储结构及实现 栈的链式存储结构，简称链栈 //链栈的结构定义 //链栈结点 typedef struct StackNode { SElemType data; struct StackNode *next; }StackNode,*LinkStackPtr; //整个链栈 typedef struct LinkStack { LinkStackPtr top;//栈顶指针 int count ; //栈元素个数 }LinkStack; 进栈操作push： //进栈操作 //插入e为新元素到链栈的栈顶 Status Push(LinkStack *S,SElemType e) { LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode)); s-\u003edata = e; //接着将当前栈顶元素赋值给新结点的直接后续， s-\u003enext = S-\u003etop; //将新结点赋值给栈顶指针top S-\u003etop = s; S-\u003ecount ++; return OK; } 出栈操作Pop： //出栈操作 //若栈不为空，就删除栈顶元素并用e来返回删除的元素， //假设变量p用来存储要删除的栈顶元素，将栈顶指针后移一位，再释放掉p Status Pop(LinkStack *S,SElemType *e) { LinkStackPtr p ; //判断栈是否为空 if (StackEmpty(S)){ return ERROR; } *e= S-\u003etop-\u003edata; //将栈顶结点指针赋值给p p = S-\u003etop; //使栈顶指针下移到后一位 S-\u003etop = S-\u003etop-\u003enext; //释放结点p free(p); S-\u003ecount--; return OK; } 4.7栈的应用： 1.递归 递归函数：直接调用自己或通过一系列的调用语句间接地调用自己的函数。 递归过程退回的顺序是它前行顺序的逆序。在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。 因此要实现这样的需求，编译器就是使用栈来实现递归 2.四则运算表达式 1.后缀（逆波兰）表达式：所有的符号都要在运算数字的后面出现 2.后缀表达式运算结果：规则:从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行算，运算结果进栈，一直到最终获得结果 3.中缀表达式：标准的四则运算表达式 4.中缀表达式转换为后缀表达式的规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分;若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。 4.8队列的定义： 队列是只允许在一端进行插入操作，一端进行删除操作的线性表 (First in First out )简称FIFO，允许插入的一头叫做队尾，允许删除的一头叫做队头 4.9队列的抽象数据类型 ADT 队列(Queue) Data //同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。 Operation InitQueue(*Q);//初始化操作，建立一个空队列Q。 DestroyQueue(*Q);//若队列Q存在，则销毁它。 ClearQueue(*Q);//将队列Q清空。 QueueEmpty(Q);// 若队列Q为空，返回true，否则返回false。 GetHead(Q, *e);//若队列Q存在且非空，用e返回队列Q的队头元素。 EnQueue(*Q, e);// 若队列Q存在，插入新元素e到队列Q中并成为队尾元素 DeQueue(*Q, *e);//删除队列Q中队头元素，并用e返回其值 QueueLength(Q);//返回队列Q的元素个数 endADT 4.10循环队列 循序存储结构的不足: 入队列操作，就是在队尾添加一个元素，时间复杂度为O(1) 出队列操作，就是从线性表下标为0的位置出列，全部元素都要移动，时间复杂度为O(n) 当只有一个元素时，队尾和对头重叠，使得操作麻烦，所以引入两个指针，一个是front指向队头元素，一个是rear指向队尾元素 的下一个位置，这样当front和rear相等时，不是只剩一个元素，而是这是一个空队列 如果一个队列即在出列也在入列，使rear超出了线性表的最大元素个数，但是队列队头还有空闲，这样的现象称为“假溢出” 循环队列定义：队头队尾相连的顺序存储结构 循环队列满的条件：(rear+1)%QueueSize==front 循环队列空的条件：rear = front 循环队列队列长度：(rear-front+QueueSize)%QueueSize 循环队列的结构定义: //QElemType的类型视实际情况而定，这里假设为int typedef int QElemType ; typedef struct { QElemType data[MAXSIZE]; int front; int rear;//尾追针，指向队列的队尾元素的下一个位置 }SqQueue; 循环列表初始化操作： Status InitSqQueue(SqQueue *Q){ Q-\u003efront=0; Q-\u003erear=0; return OK; } 获取循环列表的长度： int SqQueueLenth(SqQueue Q","date":"2023-12-24","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/:0:2","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(二)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/"},{"categories":["数据结构与算法"],"content":"第五章 串 5.1串的定义： 串(string)：是指由一个或多个字符组成的有限序列 零个字符的串就是空串 子串就是该串中连续的元素组成的子序列，包含子串的串就是主串 子串的第一个字符在主串的序号就是子串在主串的位置 5.2串的抽象数据类型 ADT 串(string) Data 串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。 Operation StrAssign(T, *chars): StrCopy(T, S): ClearString(S): StringEmpty(S): StrLength(S): StrCompare(S, T): Concat(T, S1, S2): SubString(Sub, S, pos, len) Index(S,T,pos): Replace(S,T,V): StrInsert(S,pos,T): StrDelete(S,pos,len): endADT 5.3串的存储结构 1.串的顺序存储结构：由一组内存地址连续的存储单元进行存储串中的字符序列，一般是根据预定义的长度，为串分配一个定长存储区，一般为定长数组 2.串的链式存储结构：一个结点放一个字符或者多个字符 5.4朴素的模式匹配算法 算法实现： //index //假设S[0],和T[0]存储各字符串的长度 //返回T在S的第pos个字符之后的位置 int Index(string S,string T,int pos){ //i用于S中当前位置下标，若pos不为1，则从pos位置开始 int i = pos; //j用于T中当前位置下标 int j = 1; while(i \u003cS[0] \u0026\u0026j \u003cT[0]) { //两字母相同则继续 if (S[i] == T[j]){ i ++; j++; }else { //不同就指针回退重新开始匹配 /* i退回到上次匹配首位的下一位 */ i = i - j + 2; /* j退回到子串T的首位 */ j = 1; } } if (j == T[0]){ return i -T[0]; }else { return 0; } } 5.5 KMP模式匹配算法 一脸懵逼😳，单独写个博客补充吧😭 ","date":"2023-12-24","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/:0:3","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(二)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%BA%8C/"},{"categories":["云原生"],"content":"docker基础命令，docker的核心技术，dockerfile编写","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["云原生"],"content":"docker 基础知识 ","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:0","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["云原生"],"content":"什么是docker？ Docker!=轻量级虚拟机 Docker使用的是容器化技术，docker利用的是宿主机的操作系统内核 Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问Docker守护进程。 Docker守护进程从客户端接受命令，并按照命令，管理运行在主机上的容器。 一个docker 容器，是一个运行时环境，可以简单理解为进程运行的集装箱。 ","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:1","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["云原生"],"content":"docker 命令简介 熟能生巧，这里仅做总结大部分命令作用，其实见名知意 //常见命令 //容器操作 //容器操作命令都可以加container,例：docker container run XXX docker attach //将本地标准输入、输出和错误流附加到正在运行的容器，通俗的就是可以进入容器 docker run //创建并运行一个容器,选项-d：可以让容器在后台运行 docker exec //进入一个容器,选项-it：保持标准输入打开，并分配一个伪终端 docker stats //展示运行中的容器的状态 docker start //启动一个或多个停止的容器 docker stop //停止一个或多个运行的容器 docker kill //杀死一个或多个运行的容器 docker ps //展示正在运行的容器 docker rm //删除容器 docker rmi //删除镜像 docker rename //重命名容器 docker restart //重启一个或多个容器 docker logs //记录一个容器的日志 docker top //展示运行中容器的进程信息 docker export //导出容器，通常与import联用 docker import //导入容器，通常与export联用 docker pause //暂停一个或多个容器的所有进程 docker unpause //解除一个或多个容器的所有暂停的进程 docker port //展示容器的端口映射关系 docker update //更新容器的配置文件 docker wait //阻塞直到一个或多个容器停止，打印它们的退出代码 docker commit //通过一个容器生成一个镜像 docker cp //从容器和本地主机之间复制文件或文件夹 docker diff //展示容器内文件系统的变更 //镜像操作 docker build //通过dockerfile生成一个镜像 docker images //展示所有镜像 docker pull //从dockerHub中拉取镜像 docker push //将镜像推送到dockerHub docker search //搜索镜像 docker save //存入：将一个或多个镜像打包为tar格式 docker load //加载：加载镜像保存文件，使生成镜像 docker tag //创建指定镜像的标签 (携带image子命令) docker image build //通过dockerfile生成一个镜像 docker image ls //展示所有镜像 docker image pull //拉取镜像 docker image push //推送镜像 docker image history//展示一个镜像的历史 docker image import //从tarball导入内容以创建文件系统映像 docker image inspect//展示一个或多个镜像的的详细信息 docker image load //加载：加载镜像保存文件，使生成镜像 docker image save //存入：将一个或多个镜像打包为tar格式 docker image prune //删除不用的镜像 docker image rm //删除一个或多个镜像 docker image tag //创建指定镜像的标签 //... ok啊～感觉就这些命令常用，没列出来的，还有一些详细参数就查官网吧，官网更详细。 ","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:2","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["云原生"],"content":"docker 的核心技术 先看看AI怎么说？ Linux容器（Linux Containers，LXC）：Docker利用Linux内核提供的容器化技术，实现了隔离进程、文件系统、网络和资源的轻量级虚拟化。Linux容器是Docker实现容器化的基础。 命名空间（Namespaces）：Docker使用命名空间来隔离进程的运行环境，包括PID（进程ID）、网络、IPC（进程间通信）、挂载点和UTS（主机名和域名）等。每个容器都有自己独立的命名空间，使得容器内的进程感知不到宿主机或其他容器的存在。 控制组（Control Groups，cgroups）：Docker利用控制组来限制和分配容器可使用的资源，如CPU、内存、磁盘和网络带宽等。控制组可以对容器进行资源配额和优先级管理，确保容器之间互不干扰。 联合文件系统（UnionFS）：Docker使用联合文件系统将容器的文件系统与宿主机的文件系统进行层叠并共享，以实现镜像的高效存储和容器的快速启动。常用的联合文件系统有AUFS、OverlayFS和DeviceMapper等。 Docker镜像（Docker Image）：Docker镜像是容器运行时的可执行文件，包含了运行一个容器所需的文件系统、依赖库和配置等。镜像可以通过Dockerfile定义和构建，也可以从Docker Hub等镜像仓库中获取。 Docker容器（Docker Container）：Docker容器是基于镜像创建的运行实例，可以独立运行在宿主机上，并与其他容器隔离。容器可以方便地启动、停止、暂停和销毁，提供了一种轻量级、可移植的应用部署方式。 这些核心技术共同构成了Docker的基础架构，使得Docker能够实现高效、可移植、可扩展的容器化应用部署和管理。 (总结到位，有些词汇我也不懂😭) 那么可以看出docker的三大底座：Namespaces,control Groups(cgroups),UnionFS 一.Namespaces(命名空间) Namespase 是linux内核提供的隔离进程资源的方案，虚拟资源的隔离 主要分为了7类 1.PID命名空间：隔离了进程id 2.Mount命名空间：隔离文件系统挂载点 3.Network命名空间：隔离网络设备，ip地址，路由表，防火墙等 4.UTS命名空间：隔离主机和域名 5.IPC命名空间：隔离 System V IPC 和 POSIX 消息队列(这个是啥？没学有点懵)，(IPC是linux进程间数据交互和同步的方式) 6.User命名空间：隔离用户和用户组 7.Cgroup命名空间：隔离进程组间的资源 PID隔离(没看懂，以后补充) 网络隔离： docker 提供的四种网络模式：host,container,none,bridge 默认为网桥模式 在该模式下，除了会分配隔离的网络命名空间，docker还会给容器分配ip地址 docker服务器在主机启动后，会创建一个新的docker0虚拟网桥，之后所有的服务默认情况下都会连接到该虚拟网卡 默认情况下，每个容器在创建的时候都会创建一对虚拟网卡，这一对构成一个数据通道，其中一个网卡会放在容器中，加入到docker0网桥中. docker0会为每个容器分配一个不同的ip地址，并将docker0点ip地址设置为默认网关 网桥 docker0 通过 iptables 中的配置与宿主机器上的网卡相连，所有符合条件的请求都会通过 iptables 转发到 docker0 并由网桥分发给对应的机器。 libnetwork:有待补充 容器网络模型：有待补充 二.CGroups(控制组) CGroups用户隔离宿主机的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。 每一个CGroup都是一组拥有相同属性的进程，CCroup是有层级关系的，子类可以继承父类的隔离标准 (也是挺复杂的，以后补充) 三.UnionFS(联合文件系统) 什么是镜像？ image是docker部署的基本单位，包含程序文件，以及运行所需的资源文件，对外表现为文件的形式(mount点形式) 什么是UnionFS？ UnionFS是linux点文件系统技术，用于将多个文件系统挂载到同一个挂载点 AUFS：Advanced UnionFS，UnionFS先进版,提供更优秀的性能和效率 四.总结： docker = LXC + AUFS(docker = linux container + advance UnionFS) LXC:用来进行资源管理 AUFS:用来进行镜像管理 cgroup，LXC，docker三者的关系： cgroup —–\u003eLXC——\u003edocker 进行层层封装 ","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:3","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["云原生"],"content":"DockerFile的编写 DockerFile 是文本文件， 其中的每条指令都会建立一层，每条指令就对应这一层该如何构建 FROM指定基础镜像 FROM是必备指令，也是第一条指令 可以选择现有的镜像，也可以使用scratch镜像，代表空镜像，这就意味着你不选择任何镜像作为你的基础镜像，那么接下来所写的指令将作为镜像的第一层存在 例如go开发的应用，编译之后直接生成的就是可执行的2进制文件，不需要依赖操作系统，所依赖的库都包含在了可执行文件中，所以很适合使用FROM scratch，让镜像体积变得小巧 RUN执行命令行命令 RUN指令是用来执行命令行命令的 shell格式： RUN \u003c命令\u003e exec格式： RUN [\"可执行文件\",\"参数A\",\"参数B\",...] 因为每条指令对应一层，所以尽量把多条shell命令写在同一条RUN指令中，使用\u0026\u0026连接，可以防止产生臃肿，多层的镜像 Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。 在每一层的构建结尾，记得删除无关文件，也可以避免臃肿的镜像产生 构建镜像 docker build [OPTIONS] PATH | URL | - 例如：docker build -t nginx:v3 . 镜像构建上下文(context) 通过上面的例子可以看到最后有一个 . ，. 表示当前目录，注意不要误认为是DockerFile目录，这是在指定上下文路径。 什么是上下文呢？ docker 在运行时分为docker引擎(服务端守护进程)和客户端工具,docker引擎提供了一组REAT API(docker remote API)，客户端工具通过api远程调用服务端的服务，让我们以为各种docker服务是在本机进行的，实际上是在远程的服务端进行的，这就让我们操控远程服务端引擎更加便捷。 但是，我们构建DockerFile时可不止使用RUN指令，还需要一些本地文件，但是在这样c/s架构下，该如何将本地文件提供给远程服务器？ 所以就引入了上下文这一概念，通过构建上下文，当执行docker build 命令时，就会根据构建的上下文，将所需的本地文件打包，上传到docker引擎，docker引擎展开上下文包就可以获得所有构建所需的文件 COPY ./package.json /app/ 这里的意思就是把**上下文(context)**目录下的package.json文件复制,而不是DockerFile或其他目录下 一般将DockerFile放在空目录下或项目目录下，如何该目录下没有所需文件，需要把文件复制一份，如果有不想上传给docker引擎的文件，可以通过.dockerignore指定不想上传的文件，把该文件从上下文中剔除(类似于.gitignore) DockerFile的命名不一定一定是DockerFile，也不一定是在上下文目录下 其他的 docker build 用法： 1.使用git repo构建 docker build [OPTIONS] PATH | URL | - 我们可以看到docker build 不止可以从上下文目录中构建，还可以从URL中构建，也就是说还可以从git仓库中构建，那么我们将代码上传到 GitHub上，就可以使用docker快速部署 2. 使用tar压缩包 如果URL中是一个tar压缩包，docker会去下载压缩包，并解压后构建镜像 3.从标准输入读取DockerFile进行构建(以后补充) 4.从标准输入读取上下文压缩包进行构建(以后补充) ","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:4","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["云原生"],"content":"DockerFile指令详解 除了以上提到的FROM，RUN基础指令外，还有很多需要的指令： COPY 复制文件 格式： COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] \u003c源路径\u003e... \u003c目标路径\u003e COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] [\"\u003c源路径1\u003e\",... \"\u003c目标路径\u003e\"] 源路径可以是多个，支持通配符，目标路径可以是工作目录的相对路径，也可以是绝对路径，使用相对路径需要使用WORKDIR指令指定工作目录。–chown=: 选项来改变文件的所属用户及所属组。 ADD 也是复制文件，但是比COPY高级 格式：与COPY一样 当复制一个压缩包时，使用ADD可以进行自动解压的功能(如果本来就想把压缩包复制到目标目录，而不解压缩，那就不要用ADD指令) CMD 容器启动命令 格式： shell格式 CMD \u003c命令\u003e exec格式 CMD [\"可执行文件\",\"参数A\",\"参数B\"...] 参数列表格式 CMD [\"参数A\",\"参数B\"...] (指定了ENTRYPOINT后，CMD就用来指定参数) 在运行时也可以指定新的命令来替换镜像设置的默认命令 使用shell格式的命令，实际的命令会被包装为 sh -c 的参数的形式进行执行。 一般格式推荐使用exec格式，指令会被解析为json数组，所以一定要使用双引号 容器前台运行和后台运行的问题： 因为容器内没有后台服务的概念，容器是为了主进程存在的，主进程退出，那么容器也会退出，那么执行shell格式命令时，主进程实际上是sh ，当该条命令结束后，sh也就结束了，主进程退出，那么容器就退出了，所以我们应该使用exec格式命令直接执行可执行文件，并在前台运行 ENTRYPOINT 入口点 ENTRYPOINT格式与RUN格式一样，分为shell和exec格式 ENTRYPOINT也是用来指定容器启动程序和启动参数，可以在运行时替代，需要通过 docker run 的参数 –entrypoint 来指定 当指定了ENTRYPOINT后，CMD指令就是用来指定参数，实际执行时变成了： ENTRYPOINT \u003cCMD\u003e 应用场景一：让镜像想命令一样使用 应用场景二：应用运行前的准备工作 ENV 设置环境变量 就是用来设置环境变量的 格式： ENV \u003ckey\u003e \u003cvalue\u003e ENV \u003ckey1\u003e=\u003cvalue1\u003e \u003ckey2\u003e=\u003cvalue2\u003e... ARG 构建参数 也是用来设置环境变量的，但是与ENV有区别：ARG构建的环境变量在容器运行时是不存在的 格式： ARG \u003c参数名\u003e[=\u003c默认值\u003e] Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 –build-arg \u003c参数名\u003e=\u003c值\u003e 来覆盖。 ARG指令是有生效范围的，如果在FROM前使用，那么定义的参数只能在FROM指令中使用，如果要在FROM后也使用，那么就要在FROM后也要再使用ARG指令，分别指定变量 VOLUME 定义匿名卷 VOLUME指令可以指定某些目录为匿名卷，将动态数据存储在匿名卷中，可以避免用户忘记指定数据卷，使容器正常运行，而不会将动态数据过多的存储在容器存储层 格式： VOLUME [\"路径1\",\"路径2\"] VOLUME \u003c路径\u003e EXPOSE 暴露端口 格式： EXPOSE \u003c端口一\u003e [\u003c端口二\u003e...] EXPOSE指令用于声明端口，也只是用于声明容器打算使用什么端口而已，镜像启动时也不会因为这个声明就启动该端口服务，只是用于方便镜像使用者对容器进行端口映射，另外还可以在运行时随机端口映射时，就是使用docker run -P时，可以随机端口映射到EXPOSE指定的端口 WORKDIR 指定工作目录 WORKDIR用于指定工作目录(或者成为当前目录),就是pwd的命令展示的工作目录 格式： WORKDIR \u003c工作目录\u003e 如果WORKDIR使用的是相对路径，那么所切换的路径与之前WORKDIR有关 USER 指定用户 使用USER指令时，确保用户存在 格式： USER \u003c用户名\u003e[:\u003c用户组\u003e] HEALTHYCHECK 健康检查 格式： HEALTHCHECK [选项] CMD \u003c命令\u003e：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 ONBUILD 当前镜像作为基础镜像执行 ONBUILD指令所指定的指令在当前镜像构建时不会执行，之后当当前镜像作为基础镜像时，才会执行 格式： ONBUILD \u003c其他命令\u003e LABEL 添加元数据 LABEL以减值对的形式给镜像添加元数据 LABEL \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e ... SHELL 指令 用于指定RUN CMD ENTRYPOINT指令的shell,Linux 中默认为 [\"/bin/sh\", “-c”] 格式： SHELL [\"executable\", \"parameters\"] 参考资料： 蓝山第10节课课件 docker技术入门与实战 docker入门到实践 ","date":"2023-12-24","objectID":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:5","tags":["docker"],"title":"Docker基础知识总结","uri":"/docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["微服务"],"content":"使用grpc和net/rpc分别写一个简单的rpc服务","date":"2023-12-14","objectID":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/","tags":["微服务"],"title":"简单的RPC服务demo","uri":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/"},{"categories":["微服务"],"content":"RPC learning ","date":"2023-12-14","objectID":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/:0:0","tags":["微服务"],"title":"简单的RPC服务demo","uri":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/"},{"categories":["微服务"],"content":"一.grpc demo 1.使用proto文件生成go代码: \u0026编写proto文件 //约定语法 syntax = \"proto3\"; //这部分内容是关于最后生成的go文件存在哪个文件目录，. 代表当前项目目录下，server代表最后生成的文件的名字 option go_package = \".;service\"; //service 相当于是go的函数 //service 定义一个服务，客户端可以传入参数，返回服务端的响应 //发送一个HelloRequest 返回一个HelloResponse service SayHello { rpc SayHello(HelloRequest) returns (HelloResponse) {} } //message 相当于是go的结构体， //后面的特殊\"赋值\",代表的是位置顺序,而不是真正的赋值 message HelloRequest{ string requestName = 1; } message HelloResponse{ string responseMessage = 1; } \u0026生成go代码 (记得切换到proto目录下,并注意命令中的空格以及下划线等的符号) protoc --go_out=. hello.proto protoc --go-grpc_out=. hello.proto 2.proto文件介绍： syntax:约定语法 option:这部分内容是关于最后生成的go文件存在哪个文件目录 message ：传输的消息格式的定义 1.字段规则： required:必填字段，protobuf2中使用，protobuf3中删除 optional:可选字段，protobuf3中删去了required和optional，默认optional repeate：可重复字段，重复的值的顺序会被保留到go中重复的会被定义为切片 2.消息号： 也就是看起来像赋值的\"操作\" 每个字段都必须要有的消息号[1,2^29-1]的整数 3.嵌套消息：支持嵌套消息 service:定义一个rpc服务接口 service 服务接口名{ rpc 服务函数名(参数) returns(返回参数){} } 3.服务端编写 package main import ( pb \"RPClearning/hello_server/proto\" \"context\" \"errors\" \"fmt\" \"google.golang.org/grpc\" \"google.golang.org/grpc/metadata\" \"net\" ) type server struct { pb.UnimplementedSayHelloServer } // 业务 func (s *server) SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloResponse, error) { //进行token校验 //获取元数据 注：返回的元数据切片中的所有key都是小写！小写！小写！ md, ok := metadata.FromIncomingContext(ctx) if !ok { return nil, errors.New(\"未传输token\") } var appID string var appKey string if v, ok := md[\"appid\"]; ok { appID = v[0] } if v, ok := md[\"appkey\"]; ok { appKey = v[0] } if appID != \"lance\" || appKey != \"123\" { return \u0026pb.HelloResponse{ResponseMessage: \"token错误 \" + req.RequestName}, nil } fmt.Println(\"hello \" + req.RequestName) return \u0026pb.HelloResponse{ResponseMessage: \"hello \" + req.RequestName}, nil } func main() { //监听端口 listener, _ := net.Listen(\"tcp\", \":9090\") //创建一个grpc服务 grpcServer := grpc.NewServer() //在grpc服务端中注册编写的服务 pb.RegisterSayHelloServer(grpcServer, \u0026server{}) //一定要是引用传递对象 //启动服务 err := grpcServer.Serve(listener) if err != nil { fmt.Printf(\"failed to serve :%v\", \u0026err) return } } 4.客户端编写 package main import ( pb \"RPClearning/hello_server/proto\" \"context\" \"fmt\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials/insecure\" \"log\" ) type ClientToken struct { } func (c ClientToken) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) { return map[string]string{ \"appID\" : \"lance\", \"appKey\": \"123\", }, nil } func (c ClientToken) RequireTransportSecurity() bool { return false //是否带安全验证 } func main() { //连接到server端,此处禁止安全传输 var opts []grpc.DialOption opts = append(opts, grpc.WithTransportCredentials(insecure.NewCredentials())) opts = append(opts, grpc.WithPerRPCCredentials(new(ClientToken))) conn, err := grpc.Dial(\"127.0.0.1:9090\", opts...) if err != nil { log.Fatalf(\"didn't connect :%v\", err) } defer conn.Close() //建立连接 client := pb.NewSayHelloClient(conn) //执行rpc调用（这个方法在服务端来实现，并返回结果） response, _ := client.SayHello(context.Background(), \u0026pb.HelloRequest{RequestName: \"lance\"}) res := response.GetResponseMessage() fmt.Println(\"response:\", res) } ","date":"2023-12-14","objectID":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/:0:1","tags":["微服务"],"title":"简单的RPC服务demo","uri":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/"},{"categories":["微服务"],"content":"二.net/rpc demo 1.服务端代码： package main import ( \"net\" \"net/rpc\" ) type Server struct { } // 通过阅读源码，发现method是有要求的 ： // Method needs three ins: receiver, *args, *reply. // First arg need not be a pointer. // Second arg must be a pointer. // Reply type must be exported. // Method needs one out. // The return type of the method must be error func (s Server) SayHello(args []string, what *string) error { *what = args[0] + \" say hello to \" + args[1] return nil } func main() { //新建一个对象实例 s := new(Server) //注册服务 err := rpc.Register(s) if err != nil { panic(err) } //监听 listener, errs := net.Listen(\"tcp\", \":9090\") if errs != nil { panic(err) } //启动服务 for { conn, err := listener.Accept() if err != nil { continue } go rpc.ServeConn(conn) } } 2.客户端代码 package main import ( \"fmt\" \"net/rpc\" ) var Names = []string{\"lance\", \"longxu\"} var What string func main() { client, err := rpc.Dial(\"tcp\", \"localhost:9090\") must(err) defer client.Close() //err = client.Call(\"Server.SayHello\", Names, \u0026What) //if err != nil { // panic(err) //} // ！！！！注意这里serviceMethod不应该只传入method 而是应该传入object.Method这样的格式,否则会报 service/method request ill-formed的错误 call := \u003c-client.Go(\"Server.SayHello\", Names, \u0026What, make(chan *rpc.Call, 1)).Done fmt.Println(call.ServiceMethod) fmt.Println(call.Reply) fmt.Println(call.Args) fmt.Println(call.Error) if call.Error != nil { panic(err) } fmt.Println(\"rpc调用成功，取得值：\", What) } func must(err error) { if err != nil { panic(err) } } ","date":"2023-12-14","objectID":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/:0:2","tags":["微服务"],"title":"简单的RPC服务demo","uri":"/%E7%AE%80%E5%8D%95%E7%9A%84rpc%E6%9C%8D%E5%8A%A1demo/"},{"categories":["工具"],"content":"如何使用viper配置项目","date":"2023-12-01","objectID":"/viper/","tags":["工具"],"title":"viper:Go语言配置管理神器","uri":"/viper/"},{"categories":["工具"],"content":"viper:Go语言配置管理神器 参考文档：viper 文档汉化：李文周的博客 一.安装 go get github.com/spf13/viper 二.支持特性 1.设置默认值 2.从json ,toml,yaml,hcl,envfile,java properties格式的配置文件读取配置信息 3.实时监控和重新读取配置文件(optional) 4.从环境变量中读取 5.从远程配置系统（etcd和Consul）读取并监控配置变化 6.从命令行参数读取配置 7.从buffer读取配置 8.显示配置值 三.viper可以做什么？ 1.查找，加载和反序列化json,toml,yaml,hcl,ini,envfile,java properties格式的配置文件。 2.提供一种机制为你不同配置选项指定选项的值。 3.提供一种机制来通过命令行参数覆盖指定选项的值。 4.提供别名系统，一边在不破坏现有代码的情况下轻松重命名参数。 5.当用户提供与默认值相同的命令行或配置文件时，可以很容易的分辨出它们之间的区别。 四.viper优先级 (从高到低) 1.显式调用Set设置值 2.命令行参数（flag） 3.环境变量 4.配置文件 5.key/value存储 6.默认值 五.将值存入viper 1.设置默认值： viper.SetDefault(\"name\", \"lance\")//设置name默认值为lance value := viper.GetString(\"name\") //获取默认值 fmt.Println(value)//打印lance 2.读取配置文件： viper可以搜索多个路径，但是目前单个viper实例只支持单个配置文件。 viper不默认任何配置搜索路径，将默认决策留给应用程序。 搜索配置文件： 不需要任何特定的路径，但是至少应该提供一个配置文件预期出现的路径 配置文件有扩展名： viper.SetConfigFile(\"./config.yaml\")//通过指定配置文件路径 配置文件无扩展名 viper.SetConfigName(\"config1\")//配置文件名称（本身就没有扩展名） viper.SetConfigType(\"yaml\")//没有扩展名，必须配置此项 viper.AddConfigPath(\".\")//搜索配置文件所在的路径 viper.AddConfigPath(\"./...\")//多次调用以添加多个搜索路径 ... 读取配置文件： //说明： 这里执行viper.ReadInConfig()之后，viper才能确定到底用哪个文件 err := viper.ReadInConfig() // 查找并读取配置文件 if err != nil { if err == err.(viper.ConfigFileNotFoundError) { panic(err) // 处理找不到配置文件的错误 } panic(err) } 如果有多个同名配置文件，扩展名优先级： json\u003etoml\u003eyaml\u003eyml\u003eproperties(java中的配置文件名)\u003eprops(java中的配置文件名) 3.写入配置文件： 已经预定义路径： //若没有预定义路径会报错 viper.WriteConfig()//覆盖存在的配置文件 viper.SafeWriteConfig()//不会覆盖存在的配置文件，配置文件不存在就创建配置文件 给定路径： viper.WriteConfigAs()//覆盖当前配置文件 viper.SafeWriteConfigAs()//不会覆盖存在的配置文件，配置文件不存在就创建配置文件 4.监控并重新读取配置文件： viper支持在运行时实时读取配置文件的功能 //之前已经添加好了配置路径 viper.WatchConfig() viper.OnConfigChange(func(e fsnotify.Event) { // 配置文件发生变更之后会调用的回调函数 fmt.Println(\"Config file changed:\", e.Name) }) 5.从io.Reader读取配置： 实现自己所需的配置原并将其提供给viper viper.SetConfigFile(\"./config.yaml\") config := []byte(` hello : world ping: pong `) err := viper.ReadConfig(bytes.NewBuffer(config)) if err != nil { panic(err) } //只是读取，未写入配置文件 value := viper.Get(\"ping\") fmt.Println(value) 6.覆盖设置： 这些可能来自命令行标志，也可能来自你自己的应用程序逻辑 viper.Set(\"Verbose\", true) viper.Set(\"LogFile\", LogFile) 7.注册和使用别名： 别名允许多个键引用单个值 viper.RegisterAlias(\"loud\", \"Verbose\") // 注册别名（此处loud和Verbose建立了别名） viper.Set(\"verbose\", true) // 结果与下一行相同 viper.Set(\"loud\", true) // 结果与前一行相同 viper.GetBool(\"loud\") // true viper.GetBool(\"verbose\") // true 8.使用环境变量 9.使用Flags 10.远程Key/Value存储支持 11.监控etcd中的更改-未加密 (以后有待补充) 六.从viper获取值 常用根据值类型获取值的方法： Get(key string) : interface{} GetBool(key string) : bool GetFloat64(key string) : float64 GetInt(key string) : int GetIntSlice(key string) : []int GetString(key string) : string GetStringMap(key string) : map[string]interface{} GetStringMapString(key string) : map[string]string GetStringSlice(key string) : []string GetTime(key string) : time.Time GetDuration(key string) : time.Duration IsSet(key string) : bool //判断键是否存在 AllSettings() : map[string]interface{} 1.访问嵌套的键 访问器方法也接受深度嵌套键的格式化路径。例如，如果加载下面的JSON文件： { \"host\": { \"address\": \"localhost\", \"port\": 5799 }, \"datastore\": { \"metric\": { \"host\": \"127.0.0.1\", \"port\": 3099 }, \"warehouse\": { \"host\": \"198.0.0.1\", \"port\": 2112 } } } viper通过传入 . 分隔的路径来访问嵌套字段： //已经读取了配置文件 viper.GetString(\"datastore.metric.host\")//返回127.0.0.1 如何存在键中包含 \" . “的情况，并且与分隔的键路径匹配，那么返回这个键的值： { \"datastore.metric.host\": \"0.0.0.0\", \"host\": { \"address\": \"localhost\", \"port\": 5799 }, \"datastore\": { \"metric\": { \"host\": \"127.0.0.1\", \"port\": 3099 }, \"warehouse\": { \"host\": \"198.0.0.1\", \"port\": 2112 } } } viper.GetString(\"datastore.metric.host\") // 返回 \"0.0.0.0\" （文档原文）： 这遵守上面建立的优先规则；搜索路径将遍历其余配置注册表，直到找到为止。(译注：因为Viper支持从多种配置来源，例如磁盘上的配置文件\u003e命令行标志位\u003e环境变量\u003e远程Key/Value存储\u003e默认值，我们在查找一个配置的时候如果在当前配置源中没找到，就会继续从后续的配置源查找，直到找到为止。) 例如，在给定此配置文件的情况下，datastore.metric.host和datastore.metric.port均已定义（并且可以被覆盖）。如果另外在默认值中定义了datastore.metric.protocol，Viper也会找到它。 然而，如果datastore.metric被直接赋值覆盖（被flag，环境变量，set()方法等等…），那么datastore.metric的所有子键都将变为未定义状态，它们被高优先级配置级别“遮蔽”（shadowed）了 2.提取子树 还是以上面的配置文件为例： { \"host\": { \"address\": \"localhost\", \"port\": 5799 }, \"datastore\": { \"metric\": { \"host\": \"127.0.0.1\", \"port\": 3","date":"2023-12-01","objectID":"/viper/:0:0","tags":["工具"],"title":"viper:Go语言配置管理神器","uri":"/viper/"},{"categories":["Go"],"content":"go面对对象的简短总结","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/","tags":["Go特性"],"title":"Go的面对对象","uri":"/go%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"},{"categories":["Go"],"content":"Go的面对对象 Go是面向对象的语言吗？ Yes and No. 1.Go允许OO的编程风格 2.Go的struct可以看作其他语言的Class 3.Go缺乏其他语言的继承结构 4.Go的接口与其他语言有很大差异 Go的 “类” 1.其他语言中，往往用class表示一类数据 2.calss的每个实例称作“对象” 3.Go中用struct表示一类数据 4.struct每个实例并不是“对象”，而是此类型的“值” 5.struct也可以定义方法 Go的继承 1.Go并没有继承关系 2.所谓Go的继承只是组合 3.组合中的匿名字段，通过语法糖达成了类似继承的效果 Go的接口 1.接口可以定义Go中的一组行为相似的struct 2.struct并不显式实现接口，而是隐式实现 小结 1.Go没有对象，没有类，没有继承 2.Go通过组合匿名字段来达到类似继承的效果 3.通过以上手段去掉了面对对象中复杂而冗余的部分 4.保留了基本的面对对象特性 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/:0:1","tags":["Go特性"],"title":"Go的面对对象","uri":"/go%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"},{"categories":["数据结构与算法"],"content":"学习笔记","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(一)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/"},{"categories":["数据结构与算法"],"content":"数据结构与算法入门(一) ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/:0:0","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(一)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/"},{"categories":["数据结构与算法"],"content":"第一章：数据结构绪论 1.基本概念与术语 数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。 数据元素：是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 数据项：一个数据元素可以由若干个数据项组成（是数据不可分割的最小单位） 数据对象：是性质相同的数据元素的集合，是数据的子集 数据结构：是相互之间存在的一种或多种特定关系的特定关系的数据元素的集合 2.逻辑结构和物理结构 a.逻辑结构：是指数据对象中数据元素之间的相互关系 集合结构：集合结构中的数据元素除了属于同一个集合外，它们之间没有其他关系 线性结构：线性结构中的数据元素之间是一对一的关系 树形结构：树形结构中的数据元素之间是一对多的层次关系 图形结构：图形结构中的数据元素之间是多对多的关系 b.物理结构：是指数据的逻辑结构在计算机中的存储形式 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的 c.总结： 逻辑结构是面向问题的，物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中 3.抽象数据类型 a.数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称 原子类型：是不可以再分解的基本类型，包括整型，实型，字符型等 结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的 b.抽象数据类型：是指一个数据模型及定义在该模型上的一组操作（体现了程序设计中的问题分解，抽象和信息隐藏的特性） ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/:0:1","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(一)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/"},{"categories":["数据结构与算法"],"content":"第二章：算法 1.定义 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作 2.算法的特性 a.输入输出：算法具有零个或多个输入，至少有一个或多个输出 b.有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成 c.确定性：算法的每一步骤都具有确定的含义，不会出现二义性 d.可行性：算法的每一步骤都具有确定的含义，不会出现二义性 3.算法设计的要求 a.正确性 b.可读性 c.健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果 d.时间效率高和存储量低 4.算法效率的度量方法 a.事后统计方法 b.事前分析估算方法 一个程序的运行时间，依赖于算法的好坏和问题的输入规模，问题输入规模是指输入量的多少 最终，在分析程序的运行时间时，最重要的是把程序看作是独立于程序设计语言的算法或一系列步骤 5.函数的渐近增长 给定两个函数f(n)和g(n)，那么存在一个整数N，使得对于所有的n\u003eN，f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n) 6.算法时间复杂度 算法的时间复杂 度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模 n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐 近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函 数。 推导大O阶： 1．用常数1取代运行时间中的所有加法常数。 2．在修改后的运行次数函数中，只保留最高阶项。 3．如果最高阶项存在且不是1，则去除与这个项相乘的常数。 7.算法空间复杂度 算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂 度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句 关于n所占存储空间的函数。 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/:0:2","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(一)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/"},{"categories":["数据结构与算法"],"content":"第三章：线性表 1.线性表的定义： List：零个或者多个数据元素的有限序列 2.线性表的抽象数据类型定义： ADT 线性表(List) Data 线性表的数据对象集合为{a1, a2, ......, an}，每个元素的类型均为 DataType。 其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。 数据元素之间的关系是一对一的关系。 Operation InitList(*L): 初始化操作，建立一个空的线性表L。 ListEmpty(L): 若线性表为空，返回true，否则返回false。 ClearList(*L): 将线性表清空。 GetElem(L, i, *e): 将线性表L中的第i个位置元素值返回给e。 LocateElem(L, e): 在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功； 3.线性表的顺序存储结构： 顺序存储结构：使用一段地址连续的存储单元依次存储线性表的数据元素 三个属性： 1.存储空间的起始位置：数组data，它的存储位置就是存储空间的 存储位置。 2.线性表的最大存储容量：数组长度MaxSize。 3.线性表的当前长度：length。 #define MAXSIZE 20 typedef int ElemType;//元素类型，看具体情况定，这里使用int typedef struct{ ElemType data[MAXSIZE]; int length; }SqList; 获取元素： //一些状态码 #define OK 1 #define ERROR 0 #define TRUE 1 #define FALSE 0 typedef int Status;//函数类型，其值为函数返回的状态码，如OK等 //初始条件：1\u003c= i \u003c= ListLength(L) Status GetElem(SqList L,int i ,ElemType *e){ if (L.length == 0 ||i \u003c1 || i \u003e L.length ){ return ERROR; } *e = L.data[i - 1]; return OK; } 插入元素： 思路： 如果插入位置不合理，抛出异常； 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量； 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移 动一个位置； 将要插入元素填入位置i处，表长加1。 //初始条件：1\u003c= i \u003c= ListLength(L) //操作结果：L中第i个元素前插入新元素，L的长度+1 Status ListInsert(SqList *L,int i ,ElemType e){ int k ; //判断顺序线性表是否已经满了 if (L-\u003elength == MAXSIZE){ return ERROR; } //判断i是否在范围内 if (i \u003c1 || i \u003e L-\u003elength+1){ return ERROR; } if (i \u003c L-\u003elength){ //将要插入元素后面的元素全部向后移动一位 for (k = L-\u003elength-1;k\u003e=i -1;k--){ L-\u003edata[k+1] = L-\u003edata[k]; } } L -\u003edata[i] = e; L-\u003elength ++; return OK; } 删除操作： 思路： 如果删除位置不合理，抛出异常； 取出删除元素； 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向 前移动一个位置； 表长减1。 //初始条件：1\u003c= i \u003c= ListLength(L) //操作结果：删除L中的第i个元素，并用e返回值，L的长度-1 Status ListDelete(SqList *L,int i , ElemType *e){ int k ; if (L-\u003elength == 0){ return ERROR; } if (i \u003c1 || i \u003eL-\u003elength ){ return ERROR; } *e = L-\u003edata[i-1]; if (i \u003cL-\u003elength){ //将删除的位置后续元素向前推移 for (k= i;k\u003cL-\u003elength;k++){ L-\u003edata[k-1] = L-\u003edata[k]; } } L-\u003elength --; return OK; } 4.线性表的链式存储结构 链式存储结构：用一组任意的存储单元存储线性表的 数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意 味着，这些数据元素可以存在内存未被占用的任意位置 数据域：存储数据元素信息的域 指针域：存储直接后续位置的域，存储的信息称为指针或链 这两部分组成数据元素a(i)的存储映像，称为结点(Node) 头指针：链表中第一个结点的存储位置 为方便操作，会在单链表的第一个结点前附设一个结点，称为头结点 头结点的数据域可以不存任何数据，也可以存储线性表的长度等附加信息 头结点的指针域存储指向第一个结点的指针 我们规定链表最后一个结点指针为“空”（NULL或^） 头指针与头结点的区别： 头指针： 1.头指针是指向链表第一个节点的指针，若链表有头结点，则是指向头结点的指针 2.头指针具有标识作用，所以常用头指针冠以链表的名字 3.无论链表是否为空，头指针均不为空。头指针是链表的必要元素 头结点： 1.头结点是为了操作的统一和方便而设立，放在第一个元素之前，其数据域一般无意义。 2.有了头节点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了 3.头结点不一定是链表必须元素 //单链表的链式存储结构 typedef struct Node{ ElemType data; struct Node *next; }Node; typedef struct Node *LinkList; 获取元素： 获取第i个元素的思路： 1.声明一个指针p指向链表第一个元素，初始化j为1 2.当j\u003ci 时，就遍历链表，让p的指针向后移动，不断指向下一结点，l累加1 3.若到链表末尾P为空，则说明第i个元素不存在 4.若查找成功，返回结点p的数据 //初始条件：1\u003c= i \u003c= ListLength(L) //操作结果：查L中的第i个元素，并用e返回值 Status GetElem(LinkList L,int i , ElemType *e){ int j =1;//j为计数器 LinkList p; p = L-\u003enext; while(p\u0026\u0026j\u003ci){ p = p-\u003enext; ++j; } if (!p || j\u003ei){ return ERROR; } *e =p-\u003edata; return OK; } 元素的插入与删除： 1.插入 核心步骤： s-\u003enext = p-\u003enext ; p-\u003enext = s; 具体实现： //初始条件：1\u003c= i \u003c= ListLength(L) //操作结果：在L中的第i个元素前插入新的数据元素e，L长度+1 Status ListInsert(LinkList *L,int i ,ElemType e){ int j =1 ; LinkList p,s; p = *L; //查找第i-1个元素 while(p\u0026\u0026j \u003c1){ p= p-\u003enext; ++j; } if (!p||j \u003ei){ return ERROR; } //生成新结点(c 标准函数) s = (LinkList)malloc(sizeof(Node)); s-\u003edata= e; //将p的后续结点赋值给s的后续结点 s-\u003enext = p-\u003enext; p-\u003enext = s; return OK; } 2.删除 实际上就是一步： p-\u003enext = p-\u003enext-\u003enext; 具体实现： /* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L) */ /* 操作结果：删除L的第i个结点，并用e返回其 值，L的长度减1 */ Status ListDelete(LinkList *L,int i ,ElemType *e){ int j = 1; LinkList p,q; p = *L; while(p-\u003enext \u0026\u0026j \u003ci){ p = p-\u003enext; ++j; } if (!p-\u003enext || j \u003ei){ return ERROR; } q = p-\u003enext; p-\u003enext = q-\u003enext; *e = q-\u003edata; //系统回收该结点，释放内存 free(q); return OK; } 单链表的整表创建 1.头插法： 思路： 1.声明一个指针p和计数器变量i； 2.初始化一个空链表L； 3.让L的头结点的指针指向NULL，即建立一个带头结点的单链表 4.循环： a.生成一新结点赋值给p； ​ b.随机生成一个数字赋值给p的数据域p-\u003edata; ​ c.将p插入到头结点与前一新节点之间。 实现： /* 随机产生n个元素的值，建立带表头结点的单链 线性表L（头插法） */ void CreateListHead(LinkList *L,int n ){ LinkList p; int i ; //初始化随机数种子 srand(time(0)); *L = (LinkList)malloc(sizeof(Node)); (*L)-\u003enext = NULL; for (i = 0;i\u003cn;i++){ //生成","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/:0:3","tags":["数据结构与算法"],"title":"学习笔记：数据结构与算法(一)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%80/"},{"categories":["Go"],"content":"对基本数据类型的源码分析，窥探其底层实现","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"部分基本数据类型的底层实现 基本类型的字节数 1.int大小根据系统字长 2.指针的大小也是系统字长 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:0","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"一.空结构体 1.空结构体的地址均相同（zerobase）（不被包含在其他结构体中） 2.空结构体主要是为了节约内存，内存占用为0 ​ a.结合map：只想要key不要value时，可以将value类型设置为空结构体，实现hashset ​ b.结合channel：只想让channel发一个信号，而不想携带任何信息，可以发一个空结构体，当作纯信号 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:1","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"二.字符串 runtime包对string底层实现： type stringStruct struct { str unsafe.Pointer //指向底层字节数组的指针 len int //字节长度 } ​ reflect包下的StringHeader对string相似底层实现（已被弃用） type StringHeader struct { Data uintptr Len int } 1.字符串本质是个结构体 2.Data指针指向底层的Byte数组 3.len表示Byte数组长度，而不是字符长度 字符串特点 1.字符串是一个不可改变的字节序列，不可修改 2.字符串支持切片操作，不同位置的切片底层访问的是同一块内存数据 3.由于只读的特性，相同字符串面值常量通常对应同一个字符串常量 字符串的访问 1.对字符串使用len方法得到的是字节数而不是字符数 2.对字符串直接使用下标访问，得到的是字节 3.字符串被for range遍历时，被解码成rune类型的字符 4.UTF-8 编码算法位于runtime/utf-8.go Go中的字符编码 1.所有字符使用Unicode字符集 2.使用UTF-8编码 Unicode 1.一种统一的字符集 2.囊括了159种文字的144679个字符 3.14万个字符至少需要3个字节表示 4.英文字母均排在前128个 UTF-8 1.Unicode的一种变长格式 2.128个US-ASCII字符只需要一个字节编码 3.西方常用字符需要两个字节 4.其他字符需要3个字节，极少需要4个字节 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:2","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"四.切片 切片的本质是一个结构体 runtime包对slice的底层实现： type slice struct { array unsafe.Pointer //指向底层数组 len int //切片引用的底层数组的那部分的长度 cap int //底层数组的长度就是切片的容量 } 切片的创建 1.根据数组创建（使用下标） 2.字面量：编译时插入创建数组的代码 示例： go代码 s := []int{3, 2, 1} 汇编代码（截取） 0x000e 00014 (E:/golang/GOPATH/src/GoProgram/main.go:6) LEAQ type:[3]int(SB), AX 0x0015 00021 (E:/golang/GOPATH/src/GoProgram/main.go:6) PCDATA $1, $0 0x0015 00021 (E:/golang/GOPATH/src/GoProgram/main.go:6) CALL runtime.newobject(SB) 0x001a 00026 (E:/golang/GOPATH/src/GoProgram/main.go:6) MOVQ $3, (AX) 0x0021 00033 (E:/golang/GOPATH/src/GoProgram/main.go:6) MOVQ $2, 8(AX) 0x0029 00041 (E:/golang/GOPATH/src/GoProgram/main.go:6) MOVQ $1, 16(AX) 3.make：运行时创建数组 示例 用户代码： s := make([]int) runtime包下的对make创建切片实现： func makeslice(et *_type, len, cap int) unsafe.Pointer { mem, overflow := math.MulUintptr(et.Size_, uintptr(cap)) if overflow || mem \u003e maxAlloc || len \u003c 0 || len \u003e cap { // NOTE: Produce a 'len out of range' error instead of a // 'cap out of range' error when someone does make([]T, bignumber). // 'cap out of range' is true too, but since the cap is only being // supplied implicitly, saying len is clearer. // See golang.org/issue/4085. mem, overflow := math.MulUintptr(et.Size_, uintptr(len)) if overflow || mem \u003e maxAlloc || len \u003c 0 { panicmakeslicelen() } panicmakeslicecap() } return mallocgc(mem, et, true) } 切片的追加 1.不扩容时，只调整len（编译器负责） 2.扩容时，编译时转为调用 runtime.growslice(),使用二倍长的底层数组替代原来的底层数组，废弃原底层数组 3.期望容量大于当前容量的两倍，就会使用期望容量 4.如果当前切片的长度小于1024，将容量翻倍 5.如果当前切片的长度大于1024，每次增加25% 6.切片扩容时，并发不安全，注意切片并发要加锁 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:3","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"五.map map的底层实现是哈希表(散列表)，map的本质是指针，指向一个hmap结构体（A header for a Go map.） hmap中的buckets字段指向bmap结构体（ A bucket for a Go map.），bucket（哈希桶）是map的存储结构 HashMap 的基本方案： 1.开放寻址法 2.拉链法 Go 的map go的map底层结构—–\u003eruntime.hmap: // A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go. // Make sure this stays in sync with the compiler's definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields } buckets 字段(哈希桶)是一个指针，指向一个数组：一个由很多bmap组成的数组 bmap的结构——\u003eruntime.bmap: // A bucket for a Go map. type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] \u003c minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer. } bmap包含的字段： 1.tophash：长度为8的数组，高八位，为了快速遍历 2.data：key和value，一个桶中可以放八个键值对，八个key放一个数组中，八个value放一个数组中 3.overflow：溢出bucket的地址（指向下一个bmap） key，value，overflow都不会显示出来，而是通过maptype计算偏移量获取。因为key，value的数据类型不确定，只有编译的时候才会将八个key和八个value放入哈希桶 extra字段指向mapextra结构体： mapextra结构——-\u003eruntime.mapextra: type mapextra struct { // If both key and elem do not contain pointers and are inline, then we mark bucket // type as containing no pointers. This avoids scanning such maps. // However, bmap.overflow is a pointer. In order to keep overflow buckets // alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow. // overflow and oldoverflow are only used if key and elem do not contain pointers. // overflow contains overflow buckets for hmap.buckets. // oldoverflow contains overflow buckets for hmap.oldbuckets. // The indirection allows to store a pointer to the slice in hiter. overflow *[]*bmap oldoverflow *[]*bmap // nextOverflow holds a pointer to a free overflow bucket. nextOverflow *bmap } nextOverflow字段指向下一个可用的溢出桶 map的初始化 1.make创建： 汇编代码（截取）：可以看到底层调用了runtime.makemap() 0x0020 00032 (E:/golang/GOPATH/src/GoProgram/main.go:8) CALL runtime.makemap(SB) runtime.makemap func makemap(t *maptype, hint int, h *hmap) *hmap { mem, overflow := math.MulUintptr(uintptr(hint), t.Bucket.Size_) if overflow || mem \u003e maxAlloc { hint = 0 } // initialize Hmap if h == nil { h = new(hmap) } h.hash0 = fastrand() // Find the size parameter B which will hold the requested # of elements. // For hint \u003c 0 overLoadFactor returns false since hint \u003c bucketCnt. B := uint8(0) for overLoadFactor(hint, B) { B++ } h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. if h.B != 0 { var nextOverflow *bmap h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) h.extra.nextOverflow = nextOverflow } } return h } 2.字面量 ​ a.元素少于25个时，转化为简单赋值 ​ b.元素多于25个时，转化为循环赋值 map的访问： 计算tophash map的扩容 1.map 溢出桶太多时会导致严重的性能下降 2.runtime.mapassign()可能会触发扩容的情况： ​ a.装载因子超过 6.5（平均每个槽6.5个key） ​ b.使用了太多溢出桶（溢出桶超过了普通桶） map的扩容的类型 1.等量扩容：数据不多但是溢出桶太多了 2.翻倍扩容：数据太多了 扩容步骤一： 1.创建一组新桶 2.oldbuckets指向原有的桶数组 3.bukets指向新的桶数组 4.map标记为扩容状态 扩容步骤二： 1.将所有的数据从旧桶驱逐到新桶 2.采用渐进式驱逐 3.每次操作一个旧桶时，将旧桶数据驱逐到新桶 4.读取时不进行驱逐，只判断读取新桶还是旧桶 扩容步骤三: 1.所有","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:4","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"六.接口 Go隐式接口特点 1.只要实现了接口的全部方法，就是自动实现接口 2.可以在不修改代码的情况下抽象出新的接口 （更加方便系统的扩展和重构） 接口值的底层表示 接口数据使用runtime.iface表示： type iface struct { tab *itab //指向itab结构体，itab结构体中记录了接口类型信息和实现的方法 data unsafe.Pointer //指向底层真实数据 } type itab struct { inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches. _ [4]byte fun [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter. } 类型断言 1.类型断言是一个使用在接口值上的操作 2.可以将接口值转换为其他类型值（实现或者兼容接口) 3.可以配合switch进行类型判断 结构体和结构体指针实现接口 可查看plan9汇编 go build -gcflags -S main.go 在使用结构体实现接口时，编译器会使用结构体指针再实现一遍接口，所以使用结构体和结构体指针进行初始化变量时，都不会报错。 但使用结构体指针实现接口时，编译器不会再用结构体再来实现接口，所以使用结构体初始化变量时会不通过 空接口 1.runtime.eface结构体 type eface struct { _type *_type data unsafe.Pointer } 2.空接口底层不是普通接口 3.空接口值可以承载任何数据 空接口的用途 1.作为任意类型的函数入参 2.函数调用时，会新生成一个新的接口，再传参 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:5","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"nil,空结构体，空接口区别 nil： 是六种类型的零值 每种类型的nil是不同的，无法比较 // nil is a predeclared identifier representing the zero value for a // pointer, channel, func, interface, map, or slice type. var nil Type // Type must be a pointer, channel, func, interface, map, or slice type 空结构体 1.Go中的非常特殊的类型 2.空结构体的值不是nil 3.空结构体的指针也不是nil，但是都相同（zerobase） 空接口 1.空接口不一定是nil接口，（数据是nil，类型不是nil，就不是nil接口) 2.两个属性都是nil才是nil接口 ","date":"2023-12-01","objectID":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/:0:6","tags":["go底层实现"],"title":"Go的部分基本数据类型的底层实现","uri":"/go%E7%9A%84%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"记录对runtime，编译，运行的学习笔记","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"什么是Runtime？ 就是程序的运行环境。 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:0:1","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"Go的Runtime特点： 1.没有虚拟机的概念 2.Runtime作为程序的一部分打包进二进制文件 3.Runtime随用户程序一起运行 4.Runtime与用户程序没有明显界限，直接通过函数调用 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:0:2","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"Go的Runtime能力： 1.内存管理能力 2.垃圾回收能力（GC） 3.超强的并发能力(协程调度) ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:0:3","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"Go的Runtime其他特点： 1.Runtime有一定的屏蔽系统调用能力 2.一些go的关键字其实是Runtime下的函数 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:0:4","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"总结 1.Go的Runtime负责内存管理，垃圾回收，协程调度 2.Go的Runtime被编译为用户程序的一部分，一起运行 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:0:5","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"Go是如何编译的？ ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:1:0","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"编译命令： go build -n ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:1:1","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"编译过程： 词法分析——\u003e句法分析——-\u003e语义分析——-\u003e中间码生成——-\u003e代码优化——-\u003e机器码生成———\u003e链接 词法分析： 1.将源代码分析成Token 2.Token是代码中的最小语义结构 句法分析： 1.Token序列经过处理，变成语法树（抽象语法树ast） 语义分析： 1.类型检查 2.类型推断 3.查看类型是否匹配 4.函数调用内联 5.逃逸分析 中间码生成（SSA） 1.为了处理不同平台的差异，先生成中间代码（SSA） 2.查看从代码到SSA中间码的整个过程 $env:GOSSAFUNC=\"main\" export GOSSAFUNC=main go build 代码优化： 各个步骤都会存在 机器码生成： 1.先生成plan9汇编代码 2.最后编译为机器码 3.输出的机器码为.a文件 4.查看plan9汇编代码： go build -gcflags -S main.go 链接: 将各个包进行链接，包括runtime 总结： 1.编译前端：词法分析，句法分析，语义分析 2.编译后端：中间码生成，代码优化，机器码生成 3.链接 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:1:2","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["Go"],"content":"Go程序是如何运行的？ A:程序的入口是main方法吗？： 不是的。是runtime包下的rt0_XXX.s(不是go程序，是一个汇编语言) B:运行步骤： 1.读取命令行参数 复制参数数量argc和参数值argv到栈上 2.初始化g0执行栈 a.g0是为了调度协程而产生的协程 b.g0是每个Go程序的第一个协程 3.运行时检测 a.检查各种类型的长度 b.检查指针操作 c.检查结构体字段的偏移量 d.检查atomic原子操作 e.检查CAS操作 f.检查栈大小是否是2的幂次 4.参数初始化 runtime.args a.对命令行中的参数进行处理 b.参数数量赋值给argc int32 c.参数值赋值给argv **byte 5.调度器初始化 runtime.schedinit a.全局栈空间内存分配 b.加载命令行参数到 os.Args c.堆内存空间的初始化 d.加载操作系统环境变量 e.初始化当前系统线程 f.垃圾回收器的参数初始化(GC) g.算法初始化(map,hash) h.设置 process 数量 6.创建主协程 a.创建一个新的协程，执行 runtime.main b.放入调度器等待调度 7.初始化 M a.初始化一个M，用来调度主协程 8.主协程执行主函数 a.执行runtimem 包中的 init 方法 b.启动 GC 垃圾收集器 c.执行用户包依赖的 init 方法 d.执行用户主程序 main.main() (main包中的main函数) C:总结 1.Go 启动时经历了检查，各种初始化，初始化协程调度的过程 2.main.main() 也是在协程中运行的 ","date":"2023-12-01","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/:1:3","tags":["Go底层"],"title":"学习笔记：Go的runtime，Go的编译过程，Go的运行过程","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0go%E7%9A%84runtimego%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8Bgo%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"},{"categories":["杂事"],"content":"第一篇博客，基于hugo","date":"2023-12-01","objectID":"/first_post/","tags":["杂事"],"title":"first post in hugo","uri":"/first_post/"},{"categories":["杂事"],"content":"Hello world! 将会在这里继续博客的更新 ","date":"2023-12-01","objectID":"/first_post/:0:0","tags":["杂事"],"title":"first post in hugo","uri":"/first_post/"}]